
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>numpy.ma.core &#8212; Stoner Pacakge API Documentation</title>
    <link rel="stylesheet" href="../../../_static/better.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  </head><body>
    <header id="pageheader"><h1><a href="../../../index.html ">
        Stoner Pacakge API Documentation
    </a></h1></header>
  <div class="related top">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../../../index.html">Stoner Package</a></li>
      <li>
        <a href="../../index.html">Module code</a>
      </li> 
    </ul>
  </nav>
  </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for numpy.ma.core</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">numpy.ma : a package to handle missing or invalid values.</span>

<span class="sd">This package was initially written for numarray by Paul F. Dubois</span>
<span class="sd">at Lawrence Livermore National Laboratory.</span>
<span class="sd">In 2006, the package was completely rewritten by Pierre Gerard-Marchant</span>
<span class="sd">(University of Georgia) to make the MaskedArray class a subclass of ndarray,</span>
<span class="sd">and to improve support of structured arrays.</span>


<span class="sd">Copyright 1999, 2000, 2001 Regents of the University of California.</span>
<span class="sd">Released for unlimited redistribution.</span>

<span class="sd">* Adapted for numpy_core 2005 by Travis Oliphant and (mainly) Paul Dubois.</span>
<span class="sd">* Subclassing of the base `ndarray` 2006 by Pierre Gerard-Marchant</span>
<span class="sd">  (pgmdevlist_AT_gmail_DOT_com)</span>
<span class="sd">* Improvements suggested by Reggie Dugard (reggie_AT_merfinllc_DOT_com)</span>

<span class="sd">.. moduleauthor:: Pierre Gerard-Marchant</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable-msg=E1002</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">builtins</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">__builtin__</span> <span class="k">as</span> <span class="nn">builtins</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.core.umath</span> <span class="k">as</span> <span class="nn">umath</span>
<span class="kn">import</span> <span class="nn">numpy.core.numerictypes</span> <span class="k">as</span> <span class="nn">ntypes</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">amax</span><span class="p">,</span> <span class="n">amin</span><span class="p">,</span> <span class="n">iscomplexobj</span><span class="p">,</span> <span class="n">bool_</span><span class="p">,</span> <span class="n">_NoValue</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">narray</span>
<span class="kn">from</span> <span class="nn">numpy.lib.function_base</span> <span class="k">import</span> <span class="n">angle</span>
<span class="kn">from</span> <span class="nn">numpy.compat</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">getargspec</span><span class="p">,</span> <span class="n">formatargspec</span><span class="p">,</span> <span class="n">long</span><span class="p">,</span> <span class="n">basestring</span><span class="p">,</span> <span class="n">unicode</span><span class="p">,</span> <span class="nb">bytes</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">expand_dims</span> <span class="k">as</span> <span class="n">n_expand_dims</span>
<span class="kn">from</span> <span class="nn">numpy.core.multiarray</span> <span class="k">import</span> <span class="n">normalize_axis_index</span>
<span class="kn">from</span> <span class="nn">numpy.core.numeric</span> <span class="k">import</span> <span class="n">normalize_axis_tuple</span>


<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cPickle</span> <span class="k">as</span> <span class="nn">pickle</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;MAError&#39;</span><span class="p">,</span> <span class="s1">&#39;MaskError&#39;</span><span class="p">,</span> <span class="s1">&#39;MaskType&#39;</span><span class="p">,</span> <span class="s1">&#39;MaskedArray&#39;</span><span class="p">,</span> <span class="s1">&#39;abs&#39;</span><span class="p">,</span> <span class="s1">&#39;absolute&#39;</span><span class="p">,</span>
    <span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;allclose&#39;</span><span class="p">,</span> <span class="s1">&#39;allequal&#39;</span><span class="p">,</span> <span class="s1">&#39;alltrue&#39;</span><span class="p">,</span> <span class="s1">&#39;amax&#39;</span><span class="p">,</span> <span class="s1">&#39;amin&#39;</span><span class="p">,</span>
    <span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;anom&#39;</span><span class="p">,</span> <span class="s1">&#39;anomalies&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="s1">&#39;arange&#39;</span><span class="p">,</span> <span class="s1">&#39;arccos&#39;</span><span class="p">,</span>
    <span class="s1">&#39;arccosh&#39;</span><span class="p">,</span> <span class="s1">&#39;arcsin&#39;</span><span class="p">,</span> <span class="s1">&#39;arcsinh&#39;</span><span class="p">,</span> <span class="s1">&#39;arctan&#39;</span><span class="p">,</span> <span class="s1">&#39;arctan2&#39;</span><span class="p">,</span> <span class="s1">&#39;arctanh&#39;</span><span class="p">,</span>
    <span class="s1">&#39;argmax&#39;</span><span class="p">,</span> <span class="s1">&#39;argmin&#39;</span><span class="p">,</span> <span class="s1">&#39;argsort&#39;</span><span class="p">,</span> <span class="s1">&#39;around&#39;</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">,</span> <span class="s1">&#39;asanyarray&#39;</span><span class="p">,</span>
    <span class="s1">&#39;asarray&#39;</span><span class="p">,</span> <span class="s1">&#39;bitwise_and&#39;</span><span class="p">,</span> <span class="s1">&#39;bitwise_or&#39;</span><span class="p">,</span> <span class="s1">&#39;bitwise_xor&#39;</span><span class="p">,</span> <span class="s1">&#39;bool_&#39;</span><span class="p">,</span> <span class="s1">&#39;ceil&#39;</span><span class="p">,</span>
    <span class="s1">&#39;choose&#39;</span><span class="p">,</span> <span class="s1">&#39;clip&#39;</span><span class="p">,</span> <span class="s1">&#39;common_fill_value&#39;</span><span class="p">,</span> <span class="s1">&#39;compress&#39;</span><span class="p">,</span> <span class="s1">&#39;compressed&#39;</span><span class="p">,</span>
    <span class="s1">&#39;concatenate&#39;</span><span class="p">,</span> <span class="s1">&#39;conjugate&#39;</span><span class="p">,</span> <span class="s1">&#39;convolve&#39;</span><span class="p">,</span> <span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="s1">&#39;correlate&#39;</span><span class="p">,</span> <span class="s1">&#39;cos&#39;</span><span class="p">,</span> <span class="s1">&#39;cosh&#39;</span><span class="p">,</span>
    <span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;cumprod&#39;</span><span class="p">,</span> <span class="s1">&#39;cumsum&#39;</span><span class="p">,</span> <span class="s1">&#39;default_fill_value&#39;</span><span class="p">,</span> <span class="s1">&#39;diag&#39;</span><span class="p">,</span> <span class="s1">&#39;diagonal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;divide&#39;</span><span class="p">,</span> <span class="s1">&#39;dump&#39;</span><span class="p">,</span> <span class="s1">&#39;dumps&#39;</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="s1">&#39;empty_like&#39;</span><span class="p">,</span> <span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="s1">&#39;exp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;expand_dims&#39;</span><span class="p">,</span> <span class="s1">&#39;fabs&#39;</span><span class="p">,</span> <span class="s1">&#39;filled&#39;</span><span class="p">,</span> <span class="s1">&#39;fix_invalid&#39;</span><span class="p">,</span> <span class="s1">&#39;flatten_mask&#39;</span><span class="p">,</span>
    <span class="s1">&#39;flatten_structured_array&#39;</span><span class="p">,</span> <span class="s1">&#39;floor&#39;</span><span class="p">,</span> <span class="s1">&#39;floor_divide&#39;</span><span class="p">,</span> <span class="s1">&#39;fmod&#39;</span><span class="p">,</span>
    <span class="s1">&#39;frombuffer&#39;</span><span class="p">,</span> <span class="s1">&#39;fromflex&#39;</span><span class="p">,</span> <span class="s1">&#39;fromfunction&#39;</span><span class="p">,</span> <span class="s1">&#39;getdata&#39;</span><span class="p">,</span> <span class="s1">&#39;getmask&#39;</span><span class="p">,</span>
    <span class="s1">&#39;getmaskarray&#39;</span><span class="p">,</span> <span class="s1">&#39;greater&#39;</span><span class="p">,</span> <span class="s1">&#39;greater_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;harden_mask&#39;</span><span class="p">,</span> <span class="s1">&#39;hypot&#39;</span><span class="p">,</span>
    <span class="s1">&#39;identity&#39;</span><span class="p">,</span> <span class="s1">&#39;ids&#39;</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">,</span> <span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="s1">&#39;innerproduct&#39;</span><span class="p">,</span> <span class="s1">&#39;isMA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;isMaskedArray&#39;</span><span class="p">,</span> <span class="s1">&#39;is_mask&#39;</span><span class="p">,</span> <span class="s1">&#39;is_masked&#39;</span><span class="p">,</span> <span class="s1">&#39;isarray&#39;</span><span class="p">,</span> <span class="s1">&#39;left_shift&#39;</span><span class="p">,</span>
    <span class="s1">&#39;less&#39;</span><span class="p">,</span> <span class="s1">&#39;less_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="s1">&#39;loads&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;log10&#39;</span><span class="p">,</span> <span class="s1">&#39;log2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;logical_and&#39;</span><span class="p">,</span> <span class="s1">&#39;logical_not&#39;</span><span class="p">,</span> <span class="s1">&#39;logical_or&#39;</span><span class="p">,</span> <span class="s1">&#39;logical_xor&#39;</span><span class="p">,</span> <span class="s1">&#39;make_mask&#39;</span><span class="p">,</span>
    <span class="s1">&#39;make_mask_descr&#39;</span><span class="p">,</span> <span class="s1">&#39;make_mask_none&#39;</span><span class="p">,</span> <span class="s1">&#39;mask_or&#39;</span><span class="p">,</span> <span class="s1">&#39;masked&#39;</span><span class="p">,</span>
    <span class="s1">&#39;masked_array&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_greater&#39;</span><span class="p">,</span>
    <span class="s1">&#39;masked_greater_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_inside&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_invalid&#39;</span><span class="p">,</span>
    <span class="s1">&#39;masked_less&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_less_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_not_equal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;masked_object&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_outside&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_print_option&#39;</span><span class="p">,</span>
    <span class="s1">&#39;masked_singleton&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_values&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_where&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;maximum&#39;</span><span class="p">,</span>
    <span class="s1">&#39;maximum_fill_value&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum_fill_value&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mod&#39;</span><span class="p">,</span> <span class="s1">&#39;multiply&#39;</span><span class="p">,</span> <span class="s1">&#39;mvoid&#39;</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="s1">&#39;negative&#39;</span><span class="p">,</span> <span class="s1">&#39;nomask&#39;</span><span class="p">,</span> <span class="s1">&#39;nonzero&#39;</span><span class="p">,</span>
    <span class="s1">&#39;not_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;ones&#39;</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="s1">&#39;outerproduct&#39;</span><span class="p">,</span> <span class="s1">&#39;power&#39;</span><span class="p">,</span> <span class="s1">&#39;prod&#39;</span><span class="p">,</span>
    <span class="s1">&#39;product&#39;</span><span class="p">,</span> <span class="s1">&#39;ptp&#39;</span><span class="p">,</span> <span class="s1">&#39;put&#39;</span><span class="p">,</span> <span class="s1">&#39;putmask&#39;</span><span class="p">,</span> <span class="s1">&#39;rank&#39;</span><span class="p">,</span> <span class="s1">&#39;ravel&#39;</span><span class="p">,</span> <span class="s1">&#39;remainder&#39;</span><span class="p">,</span>
    <span class="s1">&#39;repeat&#39;</span><span class="p">,</span> <span class="s1">&#39;reshape&#39;</span><span class="p">,</span> <span class="s1">&#39;resize&#39;</span><span class="p">,</span> <span class="s1">&#39;right_shift&#39;</span><span class="p">,</span> <span class="s1">&#39;round&#39;</span><span class="p">,</span> <span class="s1">&#39;round_&#39;</span><span class="p">,</span>
    <span class="s1">&#39;set_fill_value&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;sin&#39;</span><span class="p">,</span> <span class="s1">&#39;sinh&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;soften_mask&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sometrue&#39;</span><span class="p">,</span> <span class="s1">&#39;sort&#39;</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;squeeze&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="s1">&#39;subtract&#39;</span><span class="p">,</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span>
    <span class="s1">&#39;swapaxes&#39;</span><span class="p">,</span> <span class="s1">&#39;take&#39;</span><span class="p">,</span> <span class="s1">&#39;tan&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39;trace&#39;</span><span class="p">,</span> <span class="s1">&#39;transpose&#39;</span><span class="p">,</span> <span class="s1">&#39;true_divide&#39;</span><span class="p">,</span>
    <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;where&#39;</span><span class="p">,</span> <span class="s1">&#39;zeros&#39;</span><span class="p">,</span>
    <span class="p">]</span>

<span class="n">MaskType</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span>
<span class="n">nomask</span> <span class="o">=</span> <span class="n">MaskType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MaskedArrayFutureWarning</span><span class="p">(</span><span class="ne">FutureWarning</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">_deprecate_argsort_axis</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust the axis passed to argsort, warning if necessary</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr</span>
<span class="sd">        The array which argsort was called on</span>

<span class="sd">    np.ma.argsort has a long-term bug where the default of the axis argument</span>
<span class="sd">    is wrong (gh-8701), which now must be kept for backwards compatibiity.</span>
<span class="sd">    Thankfully, this only makes a difference when arrays are 2- or more-</span>
<span class="sd">    dimensional, so we only need a warning then.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># no warning needed - but switch to -1 anyway, to avoid surprising</span>
        <span class="c1"># subclasses, which are more likely to implement scalar axes.</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 2017-04-11, Numpy 1.13.0, gh-8701: warn on axis default</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;In the future the default for argsort will be axis=-1, not the &quot;</span>
            <span class="s2">&quot;current None, to match its documentation and np.argsort. &quot;</span>
            <span class="s2">&quot;Explicitly pass -1 or None to silence this warning.&quot;</span><span class="p">,</span>
            <span class="n">MaskedArrayFutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">doc_note</span><span class="p">(</span><span class="n">initialdoc</span><span class="p">,</span> <span class="n">note</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds a Notes section to an existing docstring.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">initialdoc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">note</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">initialdoc</span>

    <span class="n">notesplit</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\n\s*?Notes\n\s*?-----&#39;</span><span class="p">,</span> <span class="n">initialdoc</span><span class="p">)</span>

    <span class="n">notedoc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Notes</span>
<span class="s2">    -----</span>
<span class="s2">    </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">note</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">notesplit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">notedoc</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">    &#39;</span> <span class="o">+</span> <span class="n">notedoc</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">notesplit</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">notedoc</span><span class="p">]</span> <span class="o">+</span> <span class="n">notesplit</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>


<span class="k">def</span> <span class="nf">get_object_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the signature from obj</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">formatargspec</span><span class="p">(</span><span class="o">*</span><span class="n">getargspec</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">return</span> <span class="n">sig</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                              Exceptions                                     #</span>
<span class="c1">###############################################################################</span>


<span class="k">class</span> <span class="nc">MAError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for masked array related errors.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">MaskError</span><span class="p">(</span><span class="n">MAError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for mask related errors.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                           Filling options                                   #</span>
<span class="c1">###############################################################################</span>


<span class="c1"># b: boolean - c: complex - f: floats - i: integer - O: object - S: string</span>
<span class="n">default_filler</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                  <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mf">1.e20</span> <span class="o">+</span> <span class="mf">0.0</span><span class="n">j</span><span class="p">,</span>
                  <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mf">1.e20</span><span class="p">,</span>
                  <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="mi">999999</span><span class="p">,</span>
                  <span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="s1">&#39;?&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="sa">b</span><span class="s1">&#39;N/A&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="mi">999999</span><span class="p">,</span>
                  <span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="sa">b</span><span class="s1">&#39;???&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="sa">u</span><span class="s1">&#39;N/A&#39;</span>
                  <span class="p">}</span>

<span class="c1"># Add datetime64 and timedelta64 types</span>
<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;ms&quot;</span><span class="p">,</span> <span class="s2">&quot;us&quot;</span><span class="p">,</span> <span class="s2">&quot;ns&quot;</span><span class="p">,</span> <span class="s2">&quot;ps&quot;</span><span class="p">,</span>
          <span class="s2">&quot;fs&quot;</span><span class="p">,</span> <span class="s2">&quot;as&quot;</span><span class="p">]:</span>
    <span class="n">default_filler</span><span class="p">[</span><span class="s2">&quot;M8[&quot;</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;NaT&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">default_filler</span><span class="p">[</span><span class="s2">&quot;m8[&quot;</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="s2">&quot;NaT&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="n">max_filler</span> <span class="o">=</span> <span class="n">ntypes</span><span class="o">.</span><span class="n">_minvals</span>
<span class="n">max_filler</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]])</span>
<span class="n">min_filler</span> <span class="o">=</span> <span class="n">ntypes</span><span class="o">.</span><span class="n">_maxvals</span>
<span class="n">min_filler</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]])</span>
<span class="k">if</span> <span class="s1">&#39;float128&#39;</span> <span class="ow">in</span> <span class="n">ntypes</span><span class="o">.</span><span class="n">typeDict</span><span class="p">:</span>
    <span class="n">max_filler</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">float128</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)])</span>
    <span class="n">min_filler</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">float128</span><span class="p">,</span> <span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)])</span>


<span class="k">def</span> <span class="nf">_recursive_fill_value</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively produce a fill value for `dtype`, calling f on scalar dtypes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_recursive_fill_value</span><span class="p">(</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)[()]</span>  <span class="c1"># decay to void scalar from 0d</span>
    <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">subdtype</span><span class="p">:</span>
        <span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">subdtype</span>
        <span class="n">subval</span> <span class="o">=</span> <span class="n">_recursive_fill_value</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">subval</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_dtype_of</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert the argument for *_fill_value into a dtype &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>


<span class="k">def</span> <span class="nf">default_fill_value</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the default fill value for the argument object.</span>

<span class="sd">    The default filling value depends on the datatype of the input</span>
<span class="sd">    array or the type of the input scalar:</span>

<span class="sd">       ========  ========</span>
<span class="sd">       datatype  default</span>
<span class="sd">       ========  ========</span>
<span class="sd">       bool      True</span>
<span class="sd">       int       999999</span>
<span class="sd">       float     1.e20</span>
<span class="sd">       complex   1.e20+0j</span>
<span class="sd">       object    &#39;?&#39;</span>
<span class="sd">       string    &#39;N/A&#39;</span>
<span class="sd">       ========  ========</span>

<span class="sd">    For structured types, a structured scalar is returned, with each field the</span>
<span class="sd">    default fill value for its type.</span>

<span class="sd">    For subarray types, the fill value is an array of the same size containing</span>
<span class="sd">    the default scalar fill value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : ndarray, dtype or scalar</span>
<span class="sd">        The array data-type or scalar for which the default fill value</span>
<span class="sd">        is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fill_value : scalar</span>
<span class="sd">        The default fill value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.ma.default_fill_value(1)</span>
<span class="sd">    999999</span>
<span class="sd">    &gt;&gt;&gt; np.ma.default_fill_value(np.array([1.1, 2., np.pi]))</span>
<span class="sd">    1e+20</span>
<span class="sd">    &gt;&gt;&gt; np.ma.default_fill_value(np.dtype(complex))</span>
<span class="sd">    (1e+20+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_scalar_fill_value</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;Mm&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default_filler</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s1">&#39;?&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default_filler</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">)</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_get_dtype_of</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_recursive_fill_value</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">_scalar_fill_value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_extremum_fill_value</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">extremum</span><span class="p">,</span> <span class="n">extremum_name</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">_scalar_fill_value</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">extremum</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unsuitable type </span><span class="si">{}</span><span class="s2"> for calculating </span><span class="si">{}</span><span class="s2">.&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">extremum_name</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_get_dtype_of</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_recursive_fill_value</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">_scalar_fill_value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">minimum_fill_value</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the maximum value that can be represented by the dtype of an object.</span>

<span class="sd">    This function is useful for calculating a fill value suitable for</span>
<span class="sd">    taking the minimum of an array with a given dtype.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : ndarray, dtype or scalar</span>
<span class="sd">        An object that can be queried for it&#39;s numeric type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : scalar</span>
<span class="sd">        The maximum representable value.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If `obj` isn&#39;t a suitable numeric type.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    maximum_fill_value : The inverse function.</span>
<span class="sd">    set_fill_value : Set the filling value of a masked array.</span>
<span class="sd">    MaskedArray.fill_value : Return current fill value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.int8()</span>
<span class="sd">    &gt;&gt;&gt; ma.minimum_fill_value(a)</span>
<span class="sd">    127</span>
<span class="sd">    &gt;&gt;&gt; a = np.int32()</span>
<span class="sd">    &gt;&gt;&gt; ma.minimum_fill_value(a)</span>
<span class="sd">    2147483647</span>

<span class="sd">    An array of numeric data can also be passed.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.int8)</span>
<span class="sd">    &gt;&gt;&gt; ma.minimum_fill_value(a)</span>
<span class="sd">    127</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; ma.minimum_fill_value(a)</span>
<span class="sd">    inf</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_extremum_fill_value</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">min_filler</span><span class="p">,</span> <span class="s2">&quot;minimum&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">maximum_fill_value</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the minimum value that can be represented by the dtype of an object.</span>

<span class="sd">    This function is useful for calculating a fill value suitable for</span>
<span class="sd">    taking the maximum of an array with a given dtype.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : ndarray, dtype or scalar</span>
<span class="sd">        An object that can be queried for it&#39;s numeric type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : scalar</span>
<span class="sd">        The minimum representable value.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If `obj` isn&#39;t a suitable numeric type.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    minimum_fill_value : The inverse function.</span>
<span class="sd">    set_fill_value : Set the filling value of a masked array.</span>
<span class="sd">    MaskedArray.fill_value : Return current fill value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.int8()</span>
<span class="sd">    &gt;&gt;&gt; ma.maximum_fill_value(a)</span>
<span class="sd">    -128</span>
<span class="sd">    &gt;&gt;&gt; a = np.int32()</span>
<span class="sd">    &gt;&gt;&gt; ma.maximum_fill_value(a)</span>
<span class="sd">    -2147483648</span>

<span class="sd">    An array of numeric data can also be passed.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.int8)</span>
<span class="sd">    &gt;&gt;&gt; ma.maximum_fill_value(a)</span>
<span class="sd">    -128</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; ma.maximum_fill_value(a)</span>
<span class="sd">    -inf</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_extremum_fill_value</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">max_filler</span><span class="p">,</span> <span class="s2">&quot;maximum&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_recursive_set_fill_value</span><span class="p">(</span><span class="n">fillvalue</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a fill value for a structured dtype.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fillvalue: scalar or array_like</span>
<span class="sd">        Scalar or array representing the fill value. If it is of shorter</span>
<span class="sd">        length than the number of fields in dt, it will be resized.</span>
<span class="sd">    dt: dtype</span>
<span class="sd">        The structured dtype for which to create the fill value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val: tuple</span>
<span class="sd">        A tuple of values corresponding to the structured fill value.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fillvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">fillvalue</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">names</span><span class="p">))</span>
    <span class="n">output_value</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fillvalue</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
        <span class="n">cdtype</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cdtype</span><span class="o">.</span><span class="n">subdtype</span><span class="p">:</span>
            <span class="n">cdtype</span> <span class="o">=</span> <span class="n">cdtype</span><span class="o">.</span><span class="n">subdtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">cdtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">output_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_recursive_set_fill_value</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">cdtype</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cdtype</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output_value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_fill_value</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">ndtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private function validating the given `fill_value` for the given dtype.</span>

<span class="sd">    If fill_value is None, it is set to the default corresponding to the dtype.</span>

<span class="sd">    If fill_value is not None, its value is forced to the given dtype.</span>

<span class="sd">    The result is always a 0d array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">ndtype</span><span class="p">)</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="n">ndtype</span><span class="o">.</span><span class="n">fields</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">default_fill_value</span><span class="p">(</span><span class="n">ndtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fields</span><span class="p">:</span>
        <span class="n">fdtype</span> <span class="o">=</span> <span class="p">[(</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ndtype</span><span class="o">.</span><span class="n">descr</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">fdtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Unable to transform </span><span class="si">%s</span><span class="s2"> to dtype </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">fdtype</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_recursive_set_fill_value</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">ndtype</span><span class="p">),</span>
                                  <span class="n">dtype</span><span class="o">=</span><span class="n">ndtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">basestring</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ndtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;OSVU&#39;</span><span class="p">):</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot set fill value of string with array of dtype </span><span class="si">%s</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span> <span class="o">%</span> <span class="n">ndtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In case we want to convert 1e20 to int.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ndtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
                <span class="c1"># Raise TypeError instead of OverflowError. OverflowError</span>
                <span class="c1"># is seldom used, and the real problem here is that the</span>
                <span class="c1"># passed fill_value is not compatible with the ndtype.</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Fill value </span><span class="si">%s</span><span class="s2"> overflows dtype </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">ndtype</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">set_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the filling value of a, if a is a masked array.</span>

<span class="sd">    This function changes the fill value of the masked array `a` in place.</span>
<span class="sd">    If `a` is not a masked array, the function returns silently, without</span>
<span class="sd">    doing anything.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    fill_value : dtype</span>
<span class="sd">        Filling value. A consistency test is performed to make sure</span>
<span class="sd">        the value is compatible with the dtype of `a`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        Nothing returned by this function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    maximum_fill_value : Return the default fill value for a dtype.</span>
<span class="sd">    MaskedArray.fill_value : Return current fill value.</span>
<span class="sd">    MaskedArray.set_fill_value : Equivalent method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_where(a &lt; 3, a)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data = [-- -- -- 3 4],</span>
<span class="sd">          mask = [ True  True  True False False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.set_fill_value(a, -999)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data = [-- -- -- 3 4],</span>
<span class="sd">          mask = [ True  True  True False False],</span>
<span class="sd">          fill_value=-999)</span>

<span class="sd">    Nothing happens if `a` is not a masked array.</span>

<span class="sd">    &gt;&gt;&gt; a = range(5)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    [0, 1, 2, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; ma.set_fill_value(a, 100)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    [0, 1, 2, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; ma.set_fill_value(a, 100)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set_fill_value</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
    <span class="k">return</span>


<span class="k">def</span> <span class="nf">get_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the filling value of a, if any.  Otherwise, returns the</span>
<span class="sd">    default filling value for that type.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">fill_value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">default_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">common_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the common filling value of two masked arrays, if any.</span>

<span class="sd">    If ``a.fill_value == b.fill_value``, return the fill value,</span>
<span class="sd">    otherwise return None.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : MaskedArray</span>
<span class="sd">        The masked arrays for which to compare fill values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fill_value : scalar or None</span>
<span class="sd">        The common fill value, or None.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array([0, 1.], fill_value=3)</span>
<span class="sd">    &gt;&gt;&gt; y = np.ma.array([0, 1.], fill_value=3)</span>
<span class="sd">    &gt;&gt;&gt; np.ma.common_fill_value(x, y)</span>
<span class="sd">    3.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">get_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">get_fill_value</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t1</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return input as an array with masked data replaced by a fill value.</span>

<span class="sd">    If `a` is not a `MaskedArray`, `a` itself is returned.</span>
<span class="sd">    If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to</span>
<span class="sd">    ``a.fill_value``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : MaskedArray or array_like</span>
<span class="sd">        An input object.</span>
<span class="sd">    fill_value : scalar, optional</span>
<span class="sd">        Filling value. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        The filled array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    compressed</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],</span>
<span class="sd">    ...                                                   [1, 0, 0],</span>
<span class="sd">    ...                                                   [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; x.filled()</span>
<span class="sd">    array([[999999,      1,      2],</span>
<span class="sd">           [999999,      4,      5],</span>
<span class="sd">           [     6,      7,      8]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;filled&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Should we check for contiguity ? and a.flags[&#39;CONTIGUOUS&#39;]:</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_masked_subclass</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the youngest subclass of MaskedArray from a list of (masked) arrays.</span>

<span class="sd">    In case of siblings, the first listed takes over.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">rcls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rcls</span> <span class="o">=</span> <span class="n">MaskedArray</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arrcls</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
        <span class="n">rcls</span> <span class="o">=</span> <span class="n">arrcls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">rcls</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">rcls</span> <span class="o">=</span> <span class="n">MaskedArray</span>
        <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">arrcls</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rcls</span><span class="p">):</span>
                <span class="n">rcls</span> <span class="o">=</span> <span class="bp">cls</span>
    <span class="c1"># Don&#39;t return MaskedConstant as result: revert to MaskedArray</span>
    <span class="k">if</span> <span class="n">rcls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;MaskedConstant&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">MaskedArray</span>
    <span class="k">return</span> <span class="n">rcls</span>


<span class="k">def</span> <span class="nf">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the data of a masked array as an ndarray.</span>

<span class="sd">    Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,</span>
<span class="sd">    else return `a` as a ndarray or subclass (depending on `subok`) if not.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.</span>
<span class="sd">    subok : bool</span>
<span class="sd">        Whether to force the output to be a `pure` ndarray (False) or to</span>
<span class="sd">        return a subclass of ndarray if appropriate (True, default).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    getmask : Return the mask of a masked array, or nomask.</span>
<span class="sd">    getmaskarray : Return the mask of a masked array, or full array of False.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_equal([[1,2],[3,4]], 2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 --]</span>
<span class="sd">     [3 4]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False  True]</span>
<span class="sd">     [False False]],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.getdata(a)</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    Equivalently use the ``MaskedArray`` `data` attribute.</span>

<span class="sd">    &gt;&gt;&gt; a.data</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">subok</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="n">get_data</span> <span class="o">=</span> <span class="n">getdata</span>


<span class="k">def</span> <span class="nf">fix_invalid</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">nomask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return input with invalid data masked and replaced by a fill value.</span>

<span class="sd">    Invalid data means values of `nan`, `inf`, etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array, a (subclass of) ndarray.</span>
<span class="sd">    mask : sequence, optional</span>
<span class="sd">        Mask. Must be convertible to an array of booleans with the same</span>
<span class="sd">        shape as `data`. True indicates a masked (i.e. invalid) data.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        Whether to use a copy of `a` (True) or to fix `a` in place (False).</span>
<span class="sd">        Default is True.</span>
<span class="sd">    fill_value : scalar, optional</span>
<span class="sd">        Value used for fixing invalid data. Default is None, in which case</span>
<span class="sd">        the ``a.fill_value`` is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : MaskedArray</span>
<span class="sd">        The input array with invalid entries fixed.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A copy is performed by default.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    masked_array(data = [-- -1.0 nan inf],</span>
<span class="sd">                 mask = [ True False False False],</span>
<span class="sd">           fill_value = 1e+20)</span>
<span class="sd">    &gt;&gt;&gt; np.ma.fix_invalid(x)</span>
<span class="sd">    masked_array(data = [-- -1.0 -- --],</span>
<span class="sd">                 mask = [ True False  True  True],</span>
<span class="sd">           fill_value = 1e+20)</span>

<span class="sd">    &gt;&gt;&gt; fixed = np.ma.fix_invalid(x)</span>
<span class="sd">    &gt;&gt;&gt; fixed.data</span>
<span class="sd">    array([  1.00000000e+00,  -1.00000000e+00,   1.00000000e+20,</span>
<span class="sd">             1.00000000e+20])</span>
<span class="sd">    &gt;&gt;&gt; x.data</span>
<span class="sd">    array([  1.,  -1.,  NaN,  Inf])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">invalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">invalid</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="n">a</span><span class="o">.</span><span class="n">_mask</span> <span class="o">|=</span> <span class="n">invalid</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">fill_value</span>
    <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                                  Ufuncs                                     #</span>
<span class="c1">###############################################################################</span>


<span class="n">ufunc_domain</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">ufunc_fills</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">class</span> <span class="nc">_DomainCheckInterval</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a valid interval, so that :</span>

<span class="sd">    ``domain_check_interval(a,b)(x) == True`` where</span>
<span class="sd">    ``x &lt; a`` or ``x &gt; b``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="s2">&quot;domain_check_interval(a,b)(x) = true where x &lt; a or y &gt; b&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">):</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Execute the call behavior.&quot;</span>
        <span class="c1"># nans at masked positions cause RuntimeWarnings, even though</span>
        <span class="c1"># they are masked. To avoid this we suppress warnings.</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">),</span>
                                    <span class="n">umath</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_DomainTan</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a valid interval for the `tan` function, so that:</span>

<span class="sd">    ``domain_tan(eps) = True`` where ``abs(cos(x)) &lt; eps``</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
        <span class="s2">&quot;domain_tan(eps) = true where abs(cos(x)) &lt; eps)&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Executes the call behavior.&quot;</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">umath</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_DomainSafeDivide</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a domain for safe division.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="c1"># Delay the selection of the tolerance to here in order to reduce numpy</span>
        <span class="c1"># import times. The calculation of these parameters is a substantial</span>
        <span class="c1"># component of numpy&#39;s import time.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span>
        <span class="c1"># don&#39;t call ma ufuncs from __array_wrap__ which would fail for scalars</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">&gt;=</span> <span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_DomainGreater</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DomainGreater(v)(x) is True where x &lt;= v.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">critical_value</span><span class="p">):</span>
        <span class="s2">&quot;DomainGreater(v)(x) = true where x &lt;= v&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">critical_value</span> <span class="o">=</span> <span class="n">critical_value</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Executes the call behavior.&quot;</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">umath</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">critical_value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_DomainGreaterEqual</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DomainGreaterEqual(v)(x) is True where x &lt; v.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">critical_value</span><span class="p">):</span>
        <span class="s2">&quot;DomainGreaterEqual(v)(x) = true where x &lt; v&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">critical_value</span> <span class="o">=</span> <span class="n">critical_value</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Executes the call behavior.&quot;</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">umath</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">critical_value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_MaskedUFunc</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">ufunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">ufunc</span><span class="o">.</span><span class="vm">__doc__</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">ufunc</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Masked version of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">_MaskedUFunc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines masked version of unary operations, where invalid values are</span>
<span class="sd">    pre-masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mufunc : callable</span>
<span class="sd">        The function for which to define a masked version. Made available</span>
<span class="sd">        as ``_MaskedUnaryOperation.f``.</span>
<span class="sd">    fill : scalar, optional</span>
<span class="sd">        Filling value, default is 0.</span>
<span class="sd">    domain : class instance</span>
<span class="sd">        Domain for the function. Should be one of the ``_Domain*``</span>
<span class="sd">        classes. Default is None.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mufunc</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_MaskedUnaryOperation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mufunc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="n">ufunc_domain</span><span class="p">[</span><span class="n">mufunc</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">mufunc</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the call behavior.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="c1"># Deal with domain</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Case 1.1. : Domained function</span>
            <span class="c1"># nans at masked positions cause RuntimeWarnings, even though</span>
            <span class="c1"># they are masked. To avoid this we suppress warnings.</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Make a mask</span>
            <span class="n">m</span> <span class="o">=</span> <span class="o">~</span><span class="n">umath</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">|=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Case 1.2. : Function without a domain</span>
            <span class="c1"># Get the result and the mask</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="c1"># Case 2.1. : The result is scalarscalar</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="c1"># Case 2.2. The result is an array</span>
            <span class="c1"># We need to fill the invalid data back w/ the input Now,</span>
            <span class="c1"># that&#39;s plain silly: in C, we would just skip the element and</span>
            <span class="c1"># keep the original, but we do have to do it that way in Python</span>

            <span class="c1"># In case result has a lower dtype than the inputs (as in</span>
            <span class="c1"># equal)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1"># Transform to</span>
        <span class="n">masked_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="n">masked_result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
        <span class="n">masked_result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_result</span>


<span class="k">class</span> <span class="nc">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">_MaskedUFunc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define masked version of binary operations, where invalid</span>
<span class="sd">    values are pre-masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mbfunc : function</span>
<span class="sd">        The function for which to define a masked version. Made available</span>
<span class="sd">        as ``_MaskedBinaryOperation.f``.</span>
<span class="sd">    domain : class instance</span>
<span class="sd">        Default domain for the function. Should be one of the ``_Domain*``</span>
<span class="sd">        classes. Default is None.</span>
<span class="sd">    fillx : scalar, optional</span>
<span class="sd">        Filling value for the first argument, default is 0.</span>
<span class="sd">    filly : scalar, optional</span>
<span class="sd">        Filling value for the second argument, default is 0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mbfunc</span><span class="p">,</span> <span class="n">fillx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">filly</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        abfunc(fillx, filly) must be defined.</span>

<span class="sd">        abfunc(x, filly) = x for all x to enable reduce.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_MaskedBinaryOperation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mbfunc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fillx</span> <span class="o">=</span> <span class="n">fillx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filly</span> <span class="o">=</span> <span class="n">filly</span>
        <span class="n">ufunc_domain</span><span class="p">[</span><span class="n">mbfunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">mbfunc</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fillx</span><span class="p">,</span> <span class="n">filly</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the call behavior.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the data, as ndarray</span>
        <span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">getdata</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="c1"># Get the result</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">():</span>
            <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Get the mask for the result</span>
        <span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">mb</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ma</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mb</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">nomask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">mb</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mb</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">mb</span><span class="p">)</span>

        <span class="c1"># Case 1. : scalar</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># Case 2. : array</span>
        <span class="c1"># Revert result to da where masked</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># any errors, just abort; impossible to guarantee masked values</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">da</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># Transforms to a (subclass of) MaskedArray</span>
        <span class="n">masked_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="n">masked_result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">masked_result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">masked_result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_result</span>

    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduce `target` along the given `axis`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tclass</span> <span class="o">=</span> <span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filly</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">m</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">mr</span> <span class="o">=</span> <span class="n">nomask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span> <span class="ow">or</span> <span class="n">t</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">mr</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">tr</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mr</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">masked</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">tr</span>
        <span class="n">masked_tr</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">tclass</span><span class="p">)</span>
        <span class="n">masked_tr</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mr</span>
        <span class="k">return</span> <span class="n">masked_tr</span>

    <span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the function applied to the outer product of a and b.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">getdata</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">mb</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ma</span> <span class="ow">is</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">mb</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">nomask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ma</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">mb</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">mb</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="ow">and</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">masked</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">da</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="n">masked_d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="n">masked_d</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">return</span> <span class="n">masked_d</span>

    <span class="k">def</span> <span class="nf">accumulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Accumulate `target` along `axis` after filling with y fill</span>
<span class="sd">        value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tclass</span> <span class="o">=</span> <span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filly</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">masked_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">tclass</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_result</span>



<span class="k">class</span> <span class="nc">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">_MaskedUFunc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define binary operations that have a domain, like divide.</span>

<span class="sd">    They have no reduce, outer or accumulate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mbfunc : function</span>
<span class="sd">        The function for which to define a masked version. Made available</span>
<span class="sd">        as ``_DomainedBinaryOperation.f``.</span>
<span class="sd">    domain : class instance</span>
<span class="sd">        Default domain for the function. Should be one of the ``_Domain*``</span>
<span class="sd">        classes.</span>
<span class="sd">    fillx : scalar, optional</span>
<span class="sd">        Filling value for the first argument, default is 0.</span>
<span class="sd">    filly : scalar, optional</span>
<span class="sd">        Filling value for the second argument, default is 0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbfunc</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">fillx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">filly</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;abfunc(fillx, filly) must be defined.</span>
<span class="sd">           abfunc(x, filly) = x for all x to enable reduce.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_DomainedBinaryOperation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dbfunc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fillx</span> <span class="o">=</span> <span class="n">fillx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filly</span> <span class="o">=</span> <span class="n">filly</span>
        <span class="n">ufunc_domain</span><span class="p">[</span><span class="n">dbfunc</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">dbfunc</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fillx</span><span class="p">,</span> <span class="n">filly</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s2">&quot;Execute the call behavior.&quot;</span>
        <span class="c1"># Get the data</span>
        <span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">getdata</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="c1"># Get the result</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Get the mask as a combination of the source masks and invalid</span>
        <span class="n">m</span> <span class="o">=</span> <span class="o">~</span><span class="n">umath</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">|=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">|=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="c1"># Apply the domain</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ufunc_domain</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">|=</span> <span class="n">domain</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>
        <span class="c1"># Take care of the scalar case first</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">masked</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># When the mask is True, put back da if possible</span>
        <span class="c1"># any errors, just abort; impossible to guarantee masked values</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
            <span class="c1"># avoid using &quot;*&quot; since this may be overlaid</span>
            <span class="n">masked_da</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">da</span><span class="p">)</span>
            <span class="c1"># only add back if it can be cast safely</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">masked_da</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;safe&#39;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">masked_da</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Transforms to a (subclass of) MaskedArray</span>
        <span class="n">masked_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="n">masked_result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">masked_result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">masked_result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_result</span>


<span class="c1"># Unary ufuncs</span>
<span class="n">exp</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>
<span class="n">conjugate</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">conjugate</span><span class="p">)</span>
<span class="n">sin</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">sin</span><span class="p">)</span>
<span class="n">cos</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">cos</span><span class="p">)</span>
<span class="n">tan</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">tan</span><span class="p">)</span>
<span class="n">arctan</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arctan</span><span class="p">)</span>
<span class="n">arcsinh</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arcsinh</span><span class="p">)</span>
<span class="n">sinh</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">sinh</span><span class="p">)</span>
<span class="n">cosh</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">cosh</span><span class="p">)</span>
<span class="n">tanh</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">tanh</span><span class="p">)</span>
<span class="nb">abs</span> <span class="o">=</span> <span class="n">absolute</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">)</span>
<span class="n">angle</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>  <span class="c1"># from numpy.lib.function_base</span>
<span class="n">fabs</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">fabs</span><span class="p">)</span>
<span class="n">negative</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">negative</span><span class="p">)</span>
<span class="n">floor</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">floor</span><span class="p">)</span>
<span class="n">ceil</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
<span class="n">around</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">)</span>
<span class="n">logical_not</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">logical_not</span><span class="p">)</span>

<span class="c1"># Domained unary ufuncs</span>
<span class="n">sqrt</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">sqrt</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                             <span class="n">_DomainGreaterEqual</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
                            <span class="n">_DomainGreater</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
<span class="n">log2</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">log2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="n">_DomainGreater</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
<span class="n">log10</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">log10</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
                              <span class="n">_DomainGreater</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
<span class="n">tan</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">tan</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                            <span class="n">_DomainTan</span><span class="p">(</span><span class="mf">1e-35</span><span class="p">))</span>
<span class="n">arcsin</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arcsin</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                               <span class="n">_DomainCheckInterval</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
<span class="n">arccos</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arccos</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                               <span class="n">_DomainCheckInterval</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
<span class="n">arccosh</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arccosh</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
                                <span class="n">_DomainGreaterEqual</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
<span class="n">arctanh</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arctanh</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                                <span class="n">_DomainCheckInterval</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1e-15</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">1e-15</span><span class="p">))</span>

<span class="c1"># Binary ufuncs</span>
<span class="n">add</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>
<span class="n">subtract</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">subtract</span><span class="p">)</span>
<span class="n">multiply</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">multiply</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">arctan2</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arctan2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">equal</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">equal</span><span class="p">)</span>
<span class="n">equal</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">not_equal</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">not_equal</span><span class="p">)</span>
<span class="n">not_equal</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">less_equal</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">less_equal</span><span class="p">)</span>
<span class="n">less_equal</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">greater_equal</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">)</span>
<span class="n">greater_equal</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">less</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">less</span><span class="p">)</span>
<span class="n">less</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">greater</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">greater</span><span class="p">)</span>
<span class="n">greater</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">logical_and</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">logical_and</span><span class="p">)</span>
<span class="n">alltrue</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">logical_and</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span>
<span class="n">logical_or</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">)</span>
<span class="n">sometrue</span> <span class="o">=</span> <span class="n">logical_or</span><span class="o">.</span><span class="n">reduce</span>
<span class="n">logical_xor</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">)</span>
<span class="n">bitwise_and</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">)</span>
<span class="n">bitwise_or</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">)</span>
<span class="n">bitwise_xor</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">)</span>
<span class="n">hypot</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">hypot</span><span class="p">)</span>

<span class="c1"># Domained binary ufuncs</span>
<span class="n">divide</span> <span class="o">=</span> <span class="n">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">divide</span><span class="p">,</span> <span class="n">_DomainSafeDivide</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">true_divide</span> <span class="o">=</span> <span class="n">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">true_divide</span><span class="p">,</span>
                                       <span class="n">_DomainSafeDivide</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">floor_divide</span> <span class="o">=</span> <span class="n">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">,</span>
                                        <span class="n">_DomainSafeDivide</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">remainder</span> <span class="o">=</span> <span class="n">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">remainder</span><span class="p">,</span>
                                     <span class="n">_DomainSafeDivide</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">fmod</span> <span class="o">=</span> <span class="n">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">fmod</span><span class="p">,</span> <span class="n">_DomainSafeDivide</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">mod</span> <span class="o">=</span> <span class="n">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">_DomainSafeDivide</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                        Mask creation functions                              #</span>
<span class="c1">###############################################################################</span>


<span class="k">def</span> <span class="nf">_replace_dtype_fields_recursive</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">primitive_dtype</span><span class="p">):</span>
    <span class="s2">&quot;Private function allowing recursion in _replace_dtype_fields.&quot;</span>
    <span class="n">_recurse</span> <span class="o">=</span> <span class="n">_replace_dtype_fields_recursive</span>

    <span class="c1"># Do we have some name fields ?</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="n">descr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># Prepend the title to the name</span>
                <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">descr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">_recurse</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">primitive_dtype</span><span class="p">)))</span>
        <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">descr</span><span class="p">)</span>

    <span class="c1"># Is this some kind of composite a la (float,2)</span>
    <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">subdtype</span><span class="p">:</span>
        <span class="n">descr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">subdtype</span><span class="p">)</span>
        <span class="n">descr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_recurse</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">subdtype</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">primitive_dtype</span><span class="p">)</span>
        <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">descr</span><span class="p">))</span>

    <span class="c1"># this is a primitive type, so do a direct replacement</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">primitive_dtype</span>

    <span class="c1"># preserve identity of dtypes</span>
    <span class="k">if</span> <span class="n">new_dtype</span> <span class="o">==</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">dtype</span>

    <span class="k">return</span> <span class="n">new_dtype</span>


<span class="k">def</span> <span class="nf">_replace_dtype_fields</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">primitive_dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a dtype description list from a given dtype.</span>

<span class="sd">    Returns a new dtype object, with all fields and subtypes in the given type</span>
<span class="sd">    recursively replaced with `primitive_dtype`.</span>

<span class="sd">    Arguments are coerced to dtypes first.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">primitive_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">primitive_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_replace_dtype_fields_recursive</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">primitive_dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">make_mask_descr</span><span class="p">(</span><span class="n">ndtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a dtype description list from a given dtype.</span>

<span class="sd">    Returns a new dtype object, with the type of all fields in `ndtype` to a</span>
<span class="sd">    boolean type. Field names are not altered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ndtype : dtype</span>
<span class="sd">        The dtype to convert.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : dtype</span>
<span class="sd">        A dtype that looks like `ndtype`, the type of all fields is boolean.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; dtype = np.dtype({&#39;names&#39;:[&#39;foo&#39;, &#39;bar&#39;],</span>
<span class="sd">                          &#39;formats&#39;:[np.float32, int]})</span>
<span class="sd">    &gt;&gt;&gt; dtype</span>
<span class="sd">    dtype([(&#39;foo&#39;, &#39;&lt;f4&#39;), (&#39;bar&#39;, &#39;&lt;i4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask_descr(dtype)</span>
<span class="sd">    dtype([(&#39;foo&#39;, &#39;|b1&#39;), (&#39;bar&#39;, &#39;|b1&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask_descr(np.float32)</span>
<span class="sd">    dtype(&#39;bool&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_replace_dtype_fields</span><span class="p">(</span><span class="n">ndtype</span><span class="p">,</span> <span class="n">MaskType</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the mask of a masked array, or nomask.</span>

<span class="sd">    Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the</span>
<span class="sd">    mask is not `nomask`, else return `nomask`. To guarantee a full array</span>
<span class="sd">    of booleans of the same shape as a, use `getmaskarray`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input `MaskedArray` for which the mask is required.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    getdata : Return the data of a masked array as an ndarray.</span>
<span class="sd">    getmaskarray : Return the mask of a masked array, or full array of False.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_equal([[1,2],[3,4]], 2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 --]</span>
<span class="sd">     [3 4]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False  True]</span>
<span class="sd">     [False False]],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.getmask(a)</span>
<span class="sd">    array([[False,  True],</span>
<span class="sd">           [False, False]])</span>

<span class="sd">    Equivalently use the `MaskedArray` `mask` attribute.</span>

<span class="sd">    &gt;&gt;&gt; a.mask</span>
<span class="sd">    array([[False,  True],</span>
<span class="sd">           [False, False]])</span>

<span class="sd">    Result when mask == `nomask`</span>

<span class="sd">    &gt;&gt;&gt; b = ma.masked_array([[1,2],[3,4]])</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 2]</span>
<span class="sd">     [3 4]],</span>
<span class="sd">          mask =</span>
<span class="sd">     False,</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.nomask</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ma.getmask(b) == ma.nomask</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; b.mask == ma.nomask</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>


<span class="n">get_mask</span> <span class="o">=</span> <span class="n">getmask</span>


<span class="k">def</span> <span class="nf">getmaskarray</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the mask of a masked array, or full boolean array of False.</span>

<span class="sd">    Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and</span>
<span class="sd">    the mask is not `nomask`, else return a full boolean array of False of</span>
<span class="sd">    the same shape as `arr`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Input `MaskedArray` for which the mask is required.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    getmask : Return the mask of a masked array, or nomask.</span>
<span class="sd">    getdata : Return the data of a masked array as an ndarray.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_equal([[1,2],[3,4]], 2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 --]</span>
<span class="sd">     [3 4]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False  True]</span>
<span class="sd">     [False False]],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.getmaskarray(a)</span>
<span class="sd">    array([[False,  True],</span>
<span class="sd">           [False, False]])</span>

<span class="sd">    Result when mask == ``nomask``</span>

<span class="sd">    &gt;&gt;&gt; b = ma.masked_array([[1,2],[3,4]])</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 2]</span>
<span class="sd">     [3 4]],</span>
<span class="sd">          mask =</span>
<span class="sd">     False,</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; &gt;ma.getmaskarray(b)</span>
<span class="sd">    array([[False, False],</span>
<span class="sd">           [False, False]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mask</span>


<span class="k">def</span> <span class="nf">is_mask</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if m is a valid, standard mask.</span>

<span class="sd">    This function does not check the contents of the input, only that the</span>
<span class="sd">    type is MaskType. In particular, this function returns False if the</span>
<span class="sd">    mask has a flexible dtype.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : array_like</span>
<span class="sd">        Array to test.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : bool</span>
<span class="sd">        True if `m.dtype.type` is MaskType, False otherwise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    isMaskedArray : Test whether input is an instance of MaskedArray.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; m = ma.masked_equal([0, 1, 0, 2, 3], 0)</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    masked_array(data = [-- 1 -- 2 3],</span>
<span class="sd">          mask = [ True False  True False False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.is_mask(m)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ma.is_mask(m.mask)</span>
<span class="sd">    True</span>

<span class="sd">    Input must be an ndarray (or have similar attributes)</span>
<span class="sd">    for it to be considered a valid mask.</span>

<span class="sd">    &gt;&gt;&gt; m = [False, True, False]</span>
<span class="sd">    &gt;&gt;&gt; ma.is_mask(m)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; m = np.array([False, True, False])</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([False,  True, False])</span>
<span class="sd">    &gt;&gt;&gt; ma.is_mask(m)</span>
<span class="sd">    True</span>

<span class="sd">    Arrays with complex dtypes don&#39;t return True.</span>

<span class="sd">    &gt;&gt;&gt; dtype = np.dtype({&#39;names&#39;:[&#39;monty&#39;, &#39;pithon&#39;],</span>
<span class="sd">                          &#39;formats&#39;:[bool, bool]})</span>
<span class="sd">    &gt;&gt;&gt; dtype</span>
<span class="sd">    dtype([(&#39;monty&#39;, &#39;|b1&#39;), (&#39;pithon&#39;, &#39;|b1&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; m = np.array([(True, False), (False, True), (True, False)],</span>
<span class="sd">                     dtype=dtype)</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([(True, False), (False, True), (True, False)],</span>
<span class="sd">          dtype=[(&#39;monty&#39;, &#39;|b1&#39;), (&#39;pithon&#39;, &#39;|b1&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; ma.is_mask(m)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">MaskType</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_shrink_mask</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shrink a mask to nomask if possible</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">nomask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span>


<span class="k">def</span> <span class="nf">make_mask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">MaskType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a boolean mask from an array.</span>

<span class="sd">    Return `m` as a boolean mask, creating a copy if necessary or requested.</span>
<span class="sd">    The function can accept any sequence that is convertible to integers,</span>
<span class="sd">    or ``nomask``.  Does not require that contents must be 0s and 1s, values</span>
<span class="sd">    of 0 are interepreted as False, everything else as True.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : array_like</span>
<span class="sd">        Potential mask.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        Whether to return a copy of `m` (True) or `m` itself (False).</span>
<span class="sd">    shrink : bool, optional</span>
<span class="sd">        Whether to shrink `m` to ``nomask`` if all its values are False.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Data-type of the output mask. By default, the output mask has a</span>
<span class="sd">        dtype of MaskType (bool). If the dtype is flexible, each field has</span>
<span class="sd">        a boolean dtype. This is ignored when `m` is ``nomask``, in which</span>
<span class="sd">        case ``nomask`` is always returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : ndarray</span>
<span class="sd">        A boolean mask derived from `m`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; m = [True, False, True, True]</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask(m)</span>
<span class="sd">    array([ True, False,  True,  True])</span>
<span class="sd">    &gt;&gt;&gt; m = [1, 0, 1, 1]</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask(m)</span>
<span class="sd">    array([ True, False,  True,  True])</span>
<span class="sd">    &gt;&gt;&gt; m = [1, 0, 2, -3]</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask(m)</span>
<span class="sd">    array([ True, False,  True,  True])</span>

<span class="sd">    Effect of the `shrink` parameter.</span>

<span class="sd">    &gt;&gt;&gt; m = np.zeros(4)</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([ 0.,  0.,  0.,  0.])</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask(m)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask(m, shrink=False)</span>
<span class="sd">    array([False, False, False, False])</span>

<span class="sd">    Using a flexible `dtype`.</span>

<span class="sd">    &gt;&gt;&gt; m = [1, 0, 1, 1]</span>
<span class="sd">    &gt;&gt;&gt; n = [0, 1, 0, 0]</span>
<span class="sd">    &gt;&gt;&gt; arr = []</span>
<span class="sd">    &gt;&gt;&gt; for man, mouse in zip(m, n):</span>
<span class="sd">    ...     arr.append((man, mouse))</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    [(1, 0), (0, 1), (1, 0), (1, 0)]</span>
<span class="sd">    &gt;&gt;&gt; dtype = np.dtype({&#39;names&#39;:[&#39;man&#39;, &#39;mouse&#39;],</span>
<span class="sd">                          &#39;formats&#39;:[int, int]})</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array(arr, dtype=dtype)</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([(1, 0), (0, 1), (1, 0), (1, 0)],</span>
<span class="sd">          dtype=[(&#39;man&#39;, &#39;&lt;i4&#39;), (&#39;mouse&#39;, &#39;&lt;i4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask(arr, dtype=dtype)</span>
<span class="sd">    array([(True, False), (False, True), (True, False), (True, False)],</span>
<span class="sd">          dtype=[(&#39;man&#39;, &#39;|b1&#39;), (&#39;mouse&#39;, &#39;|b1&#39;)])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nomask</span>

    <span class="c1"># Make sure the input dtype is valid.</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># legacy boolean special case: &quot;existence of fields implies true&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Fill the mask in case there are missing data; turn it into an ndarray.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Bas les masques !</span>
    <span class="k">if</span> <span class="n">shrink</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_shrink_mask</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">make_mask_none</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a boolean mask of the given shape, filled with False.</span>

<span class="sd">    This function returns a boolean ndarray with all entries False, that can</span>
<span class="sd">    be used in common mask manipulations. If a complex dtype is specified, the</span>
<span class="sd">    type of each field is converted to a boolean type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    newshape : tuple</span>
<span class="sd">        A tuple indicating the shape of the mask.</span>
<span class="sd">    dtype : {None, dtype}, optional</span>
<span class="sd">        If None, use a MaskType instance. Otherwise, use a new datatype with</span>
<span class="sd">        the same fields as `dtype`, converted to boolean types.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : ndarray</span>
<span class="sd">        An ndarray of appropriate shape and dtype, filled with False.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    make_mask : Create a boolean mask from an array.</span>
<span class="sd">    make_mask_descr : Construct a dtype description list from a given dtype.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask_none((3,))</span>
<span class="sd">    array([False, False, False])</span>

<span class="sd">    Defining a more complex dtype.</span>

<span class="sd">    &gt;&gt;&gt; dtype = np.dtype({&#39;names&#39;:[&#39;foo&#39;, &#39;bar&#39;],</span>
<span class="sd">                          &#39;formats&#39;:[np.float32, int]})</span>
<span class="sd">    &gt;&gt;&gt; dtype</span>
<span class="sd">    dtype([(&#39;foo&#39;, &#39;&lt;f4&#39;), (&#39;bar&#39;, &#39;&lt;i4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask_none((3,), dtype=dtype)</span>
<span class="sd">    array([(False, False), (False, False), (False, False)],</span>
<span class="sd">          dtype=[(&#39;foo&#39;, &#39;|b1&#39;), (&#39;bar&#39;, &#39;|b1&#39;)])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">MaskType</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">make_mask_descr</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">mask_or</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine two masks with the ``logical_or`` operator.</span>

<span class="sd">    The result may be a view on `m1` or `m2` if the other is `nomask`</span>
<span class="sd">    (i.e. False).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m1, m2 : array_like</span>
<span class="sd">        Input masks.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If copy is False and one of the inputs is `nomask`, return a view</span>
<span class="sd">        of the other input mask. Defaults to False.</span>
<span class="sd">    shrink : bool, optional</span>
<span class="sd">        Whether to shrink the output to `nomask` if all its values are</span>
<span class="sd">        False. Defaults to True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : output mask</span>
<span class="sd">        The result masks values that are masked in either `m1` or `m2`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `m1` and `m2` have different flexible dtypes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; m1 = np.ma.make_mask([0, 1, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; m2 = np.ma.make_mask([1, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.mask_or(m1, m2)</span>
<span class="sd">    array([ True,  True,  True, False])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_recursive_mask_or</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">newmask</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">current1</span> <span class="o">=</span> <span class="n">m1</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">current1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">_recursive_mask_or</span><span class="p">(</span><span class="n">current1</span><span class="p">,</span> <span class="n">m2</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">newmask</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">current1</span><span class="p">,</span> <span class="n">m2</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">newmask</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m1</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m1</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">MaskType</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="n">shrink</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m2</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m2</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">MaskType</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="n">shrink</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m1</span> <span class="ow">is</span> <span class="n">m2</span> <span class="ow">and</span> <span class="n">is_mask</span><span class="p">(</span><span class="n">m1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">m1</span>
    <span class="p">(</span><span class="n">dtype1</span><span class="p">,</span> <span class="n">dtype2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dtype1</span> <span class="o">!=</span> <span class="n">dtype2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible dtypes &#39;</span><span class="si">%s</span><span class="s2">&#39;&lt;&gt;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dtype1</span><span class="p">,</span> <span class="n">dtype2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">dtype1</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="c1"># Allocate an output mask array with the properly broadcast shape.</span>
        <span class="n">newmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype1</span><span class="p">)</span>
        <span class="n">_recursive_mask_or</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">newmask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newmask</span>
    <span class="k">return</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="n">shrink</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">flatten_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a completely flattened version of the mask, where nested fields</span>
<span class="sd">    are collapsed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        Input array, which will be interpreted as booleans.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flattened_mask : ndarray of bools</span>
<span class="sd">        The flattened input.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; mask = np.array([0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; flatten_mask(mask)</span>
<span class="sd">    array([False, False,  True])</span>

<span class="sd">    &gt;&gt;&gt; mask = np.array([(0, 0), (0, 1)], dtype=[(&#39;a&#39;, bool), (&#39;b&#39;, bool)])</span>
<span class="sd">    &gt;&gt;&gt; flatten_mask(mask)</span>
<span class="sd">    array([False, False, False,  True])</span>

<span class="sd">    &gt;&gt;&gt; mdtype = [(&#39;a&#39;, bool), (&#39;b&#39;, [(&#39;ba&#39;, bool), (&#39;bb&#39;, bool)])]</span>
<span class="sd">    &gt;&gt;&gt; mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)</span>
<span class="sd">    &gt;&gt;&gt; flatten_mask(mask)</span>
<span class="sd">    array([False, False, False, False, False,  True])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_flatmask</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
        <span class="s2">&quot;Flatten the mask and returns a (maybe nested) sequence of booleans.&quot;</span>
        <span class="n">mnames</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">if</span> <span class="n">mnames</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">flatten_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">mnames</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">_flatsequence</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
        <span class="s2">&quot;Generates a flattened version of the sequence.&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">_flatsequence</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">f</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">element</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">sequence</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">flattened</span> <span class="o">=</span> <span class="n">_flatsequence</span><span class="p">(</span><span class="n">_flatmask</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">flattened</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_mask_axis</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="s2">&quot;Check whether there are masked values along the given axis&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nomask</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                             Masking functions                               #</span>
<span class="c1">###############################################################################</span>

<span class="k">def</span> <span class="nf">masked_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where a condition is met.</span>

<span class="sd">    Return `a` as an array masked where `condition` is True.</span>
<span class="sd">    Any masked values of `a` or `condition` are also masked in the output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition : array_like</span>
<span class="sd">        Masking condition.  When `condition` tests floating point values for</span>
<span class="sd">        equality, consider using ``masked_values`` instead.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to mask.</span>
<span class="sd">    copy : bool</span>
<span class="sd">        If True (default) make a copy of `a` in the result.  If False modify</span>
<span class="sd">        `a` in place and return a view.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : MaskedArray</span>
<span class="sd">        The result of masking `a` where `condition` is True.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_values : Mask using floating point equality.</span>
<span class="sd">    masked_equal : Mask where equal to a given value.</span>
<span class="sd">    masked_not_equal : Mask where `not` equal to a given value.</span>
<span class="sd">    masked_less_equal : Mask where less than or equal to a given value.</span>
<span class="sd">    masked_greater_equal : Mask where greater than or equal to a given value.</span>
<span class="sd">    masked_less : Mask where less than a given value.</span>
<span class="sd">    masked_greater : Mask where greater than a given value.</span>
<span class="sd">    masked_inside : Mask inside a given interval.</span>
<span class="sd">    masked_outside : Mask outside a given interval.</span>
<span class="sd">    masked_invalid : Mask invalid values (NaNs or infs).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_where(a &lt;= 2, a)</span>
<span class="sd">    masked_array(data = [-- -- -- 3],</span>
<span class="sd">          mask = [ True  True  True False],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    Mask array `b` conditional on `a`.</span>

<span class="sd">    &gt;&gt;&gt; b = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_where(a == 2, b)</span>
<span class="sd">    masked_array(data = [a b -- d],</span>
<span class="sd">          mask = [False False  True False],</span>
<span class="sd">          fill_value=N/A)</span>

<span class="sd">    Effect of the `copy` argument.</span>

<span class="sd">    &gt;&gt;&gt; c = ma.masked_where(a &lt;= 2, a)</span>
<span class="sd">    &gt;&gt;&gt; c</span>
<span class="sd">    masked_array(data = [-- -- -- 3],</span>
<span class="sd">          mask = [ True  True  True False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; c[0] = 99</span>
<span class="sd">    &gt;&gt;&gt; c</span>
<span class="sd">    masked_array(data = [99 -- -- 3],</span>
<span class="sd">          mask = [False  True  True False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; c = ma.masked_where(a &lt;= 2, a, copy=False)</span>
<span class="sd">    &gt;&gt;&gt; c[0] = 99</span>
<span class="sd">    &gt;&gt;&gt; c</span>
<span class="sd">    masked_array(data = [99 -- -- 3],</span>
<span class="sd">          mask = [False  True  True False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([99,  1,  2,  3])</span>

<span class="sd">    When `condition` or `a` contain masked values.</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_where(a == 2, a)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data = [0 1 -- 3],</span>
<span class="sd">          mask = [False False  True False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; b = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; b = ma.masked_where(b == 0, b)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    masked_array(data = [-- 1 2 3],</span>
<span class="sd">          mask = [ True False False False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_where(a == 3, b)</span>
<span class="sd">    masked_array(data = [-- 1 -- --],</span>
<span class="sd">          mask = [ True False  True  True],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure that condition is a valid standard-type mask.</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="p">(</span><span class="n">cshape</span><span class="p">,</span> <span class="n">ashape</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cshape</span> <span class="ow">and</span> <span class="n">cshape</span> <span class="o">!=</span> <span class="n">ashape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Inconsistent shape between the condition and the input&quot;</span>
                         <span class="s2">&quot; (got </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cshape</span><span class="p">,</span> <span class="n">ashape</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">):</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">MaskedArray</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="c1"># Assign to *.mask so that structured masks are handled correctly.</span>
    <span class="n">result</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">_shrink_mask</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">masked_greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where greater than a given value.</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = (x &gt; value).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_greater(a, 2)</span>
<span class="sd">    masked_array(data = [0 1 2 --],</span>
<span class="sd">          mask = [False False False  True],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">masked_greater_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where greater than or equal to a given value.</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = (x &gt;= value).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_greater_equal(a, 2)</span>
<span class="sd">    masked_array(data = [0 1 -- --],</span>
<span class="sd">          mask = [False False  True  True],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">masked_less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where less than a given value.</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = (x &lt; value).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_less(a, 2)</span>
<span class="sd">    masked_array(data = [-- -- 2 3],</span>
<span class="sd">          mask = [ True  True False False],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">masked_less_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where less than or equal to a given value.</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = (x &lt;= value).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_less_equal(a, 2)</span>
<span class="sd">    masked_array(data = [-- -- -- 3],</span>
<span class="sd">          mask = [ True  True  True False],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">less_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">masked_not_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where `not` equal to a given value.</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = (x != value).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_not_equal(a, 2)</span>
<span class="sd">    masked_array(data = [-- -- 2 --],</span>
<span class="sd">          mask = [ True  True False  True],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">not_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">masked_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where equal to a given value.</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = (x == value).  For floating point arrays,</span>
<span class="sd">    consider using ``masked_values(x, value)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>
<span class="sd">    masked_values : Mask using floating point equality.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_equal(a, 2)</span>
<span class="sd">    masked_array(data = [0 1 -- 3],</span>
<span class="sd">          mask = [False False  True False],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">output</span>


<span class="k">def</span> <span class="nf">masked_inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array inside a given interval.</span>

<span class="sd">    Shortcut to ``masked_where``, where `condition` is True for `x` inside</span>
<span class="sd">    the interval [v1,v2] (v1 &lt;= x &lt;= v2).  The boundaries `v1` and `v2`</span>
<span class="sd">    can be given in either order.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The array `x` is prefilled with its filling value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_inside(x, -0.3, 0.3)</span>
<span class="sd">    masked_array(data = [0.31 1.2 -- -- -0.4 -1.1],</span>
<span class="sd">          mask = [False False  True  True False False],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    The order of `v1` and `v2` doesn&#39;t matter.</span>

<span class="sd">    &gt;&gt;&gt; ma.masked_inside(x, 0.3, -0.3)</span>
<span class="sd">    masked_array(data = [0.31 1.2 -- -- -0.4 -1.1],</span>
<span class="sd">          mask = [False False  True  True False False],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">:</span>
        <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
    <span class="n">xf</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">xf</span> <span class="o">&gt;=</span> <span class="n">v1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xf</span> <span class="o">&lt;=</span> <span class="n">v2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">masked_outside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array outside a given interval.</span>

<span class="sd">    Shortcut to ``masked_where``, where `condition` is True for `x` outside</span>
<span class="sd">    the interval [v1,v2] (x &lt; v1)|(x &gt; v2).</span>
<span class="sd">    The boundaries `v1` and `v2` can be given in either order.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The array `x` is prefilled with its filling value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_outside(x, -0.3, 0.3)</span>
<span class="sd">    masked_array(data = [-- -- 0.01 0.2 -- --],</span>
<span class="sd">          mask = [ True  True False False  True  True],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    The order of `v1` and `v2` doesn&#39;t matter.</span>

<span class="sd">    &gt;&gt;&gt; ma.masked_outside(x, 0.3, -0.3)</span>
<span class="sd">    masked_array(data = [-- -- 0.01 0.2 -- --],</span>
<span class="sd">          mask = [ True  True False False  True  True],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">:</span>
        <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
    <span class="n">xf</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">xf</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">xf</span> <span class="o">&gt;</span> <span class="n">v2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">masked_object</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask the array `x` where the data are exactly equal to value.</span>

<span class="sd">    This function is similar to `masked_values`, but only suitable</span>
<span class="sd">    for object arrays: for floating point, use `masked_values` instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Array to mask</span>
<span class="sd">    value : object</span>
<span class="sd">        Comparison value</span>
<span class="sd">    copy : {True, False}, optional</span>
<span class="sd">        Whether to return a copy of `x`.</span>
<span class="sd">    shrink : {True, False}, optional</span>
<span class="sd">        Whether to collapse a mask full of False to nomask</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : MaskedArray</span>
<span class="sd">        The result of masking `x` where equal to `value`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>
<span class="sd">    masked_equal : Mask where equal to a given value (integers).</span>
<span class="sd">    masked_values : Mask using floating point equality.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; food = np.array([&#39;green_eggs&#39;, &#39;ham&#39;], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; # don&#39;t eat spoiled food</span>
<span class="sd">    &gt;&gt;&gt; eat = ma.masked_object(food, &#39;green_eggs&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(eat)</span>
<span class="sd">    [-- ham]</span>
<span class="sd">    &gt;&gt;&gt; # plain ol` ham is boring</span>
<span class="sd">    &gt;&gt;&gt; fresh_food = np.array([&#39;cheese&#39;, &#39;ham&#39;, &#39;pineapple&#39;], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; eat = ma.masked_object(fresh_food, &#39;green_eggs&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(eat)</span>
<span class="sd">    [cheese ham pineapple]</span>

<span class="sd">    Note that `mask` is set to ``nomask`` if possible.</span>

<span class="sd">    &gt;&gt;&gt; eat</span>
<span class="sd">    masked_array(data = [cheese ham pineapple],</span>
<span class="sd">          mask = False,</span>
<span class="sd">          fill_value=?)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">isMaskedArray</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_mask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">nomask</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="n">shrink</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">masked_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask using floating point equality.</span>

<span class="sd">    Return a MaskedArray, masked where the data in array `x` are approximately</span>
<span class="sd">    equal to `value`, determined using `isclose`. The default tolerances for</span>
<span class="sd">    `masked_values` are the same as those for `isclose`.</span>

<span class="sd">    For integer types, exact equality is used, in the same way as</span>
<span class="sd">    `masked_equal`.</span>

<span class="sd">    The fill_value is set to `value` and the mask is set to ``nomask`` if</span>
<span class="sd">    possible.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Array to mask.</span>
<span class="sd">    value : float</span>
<span class="sd">        Masking value.</span>
<span class="sd">    rtol, atol : float, optional</span>
<span class="sd">        Tolerance parameters passed on to `isclose`</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        Whether to return a copy of `x`.</span>
<span class="sd">    shrink : bool, optional</span>
<span class="sd">        Whether to collapse a mask full of False to ``nomask``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : MaskedArray</span>
<span class="sd">        The result of masking `x` where approximately equal to `value`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>
<span class="sd">    masked_equal : Mask where equal to a given value (integers).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 1.1, 2, 1.1, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_values(x, 1.1)</span>
<span class="sd">    masked_array(data = [1.0 -- 2.0 -- 3.0],</span>
<span class="sd">          mask = [False  True False  True False],</span>
<span class="sd">          fill_value=1.1)</span>

<span class="sd">    Note that `mask` is set to ``nomask`` if possible.</span>

<span class="sd">    &gt;&gt;&gt; ma.masked_values(x, 1.5)</span>
<span class="sd">    masked_array(data = [ 1.   1.1  2.   1.1  3. ],</span>
<span class="sd">          mask = False,</span>
<span class="sd">          fill_value=1.5)</span>

<span class="sd">    For integers, the fill value will be different in general to the</span>
<span class="sd">    result of ``masked_equal``.</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_values(x, 2)</span>
<span class="sd">    masked_array(data = [0 1 -- 3 4],</span>
<span class="sd">          mask = [False False  True False False],</span>
<span class="sd">          fill_value=2)</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_equal(x, 2)</span>
<span class="sd">    masked_array(data = [0 1 -- 3 4],</span>
<span class="sd">          mask = [False False  True False False],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xnew</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">xnew</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shrink</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">shrink_mask</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">masked_invalid</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where invalid values occur (NaNs or infs).</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.</span>
<span class="sd">    Only applies to arrays with a dtype where NaNs or infs make sense</span>
<span class="sd">    (i.e. floating point types), but accepts any array_like object.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(5, dtype=float)</span>
<span class="sd">    &gt;&gt;&gt; a[2] = np.NaN</span>
<span class="sd">    &gt;&gt;&gt; a[3] = np.PINF</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([  0.,   1.,  NaN,  Inf,   4.])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_invalid(a)</span>
<span class="sd">    masked_array(data = [0.0 1.0 -- -- 4.0],</span>
<span class="sd">          mask = [False False  True  True False],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">condition</span> <span class="o">|=</span> <span class="n">mask</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">MaskedArray</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">condition</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                            Printing options                                 #</span>
<span class="c1">###############################################################################</span>


<span class="k">class</span> <span class="nc">_MaskedPrintOption</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handle the string used to represent missing data in a masked array.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the masked_print_option object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display</span> <span class="o">=</span> <span class="n">display</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enabled</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display the string to print for masked values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display</span>

    <span class="k">def</span> <span class="nf">set_display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the string to print for masked values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display</span> <span class="o">=</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the use of the display value enabled?</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enabled</span>

    <span class="k">def</span> <span class="nf">enable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the enabling shrink to `shrink`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enabled</span> <span class="o">=</span> <span class="n">shrink</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_display</span><span class="p">)</span>

    <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span>

<span class="c1"># if you single index into a masked location you get this object.</span>
<span class="n">masked_print_option</span> <span class="o">=</span> <span class="n">_MaskedPrintOption</span><span class="p">(</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_recursive_printoption</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">printopt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Puts printoptions in result where mask is True.</span>

<span class="sd">    Private function allowing for recursion</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
    <span class="k">if</span> <span class="n">names</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">curdata</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">curmask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">_recursive_printoption</span><span class="p">(</span><span class="n">curdata</span><span class="p">,</span> <span class="n">curmask</span><span class="p">,</span> <span class="n">printopt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">printopt</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">return</span>

<span class="c1"># For better or worse, these end in a newline</span>
<span class="n">_legacy_print_templates</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">long_std</span><span class="o">=</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">        masked_</span><span class="si">%(name)s</span><span class="s2">(data =</span>
<span class="s2">         </span><span class="si">%(data)s</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">%(nlen)s</span><span class="s2">        mask =</span>
<span class="s2">         </span><span class="si">%(mask)s</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">%(nlen)s</span><span class="s2">  fill_value = </span><span class="si">%(fill)s</span><span class="s2">)</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">),</span>
    <span class="n">long_flx</span><span class="o">=</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">        masked_</span><span class="si">%(name)s</span><span class="s2">(data =</span>
<span class="s2">         </span><span class="si">%(data)s</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">%(nlen)s</span><span class="s2">        mask =</span>
<span class="s2">         </span><span class="si">%(mask)s</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">%(nlen)s</span><span class="s2">  fill_value = </span><span class="si">%(fill)s</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">%(nlen)s</span><span class="s2">       dtype = </span><span class="si">%(dtype)s</span><span class="s2">)</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">),</span>
    <span class="n">short_std</span><span class="o">=</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">        masked_</span><span class="si">%(name)s</span><span class="s2">(data = </span><span class="si">%(data)s</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">%(nlen)s</span><span class="s2">        mask = </span><span class="si">%(mask)s</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">%(nlen)s</span><span class="s2">  fill_value = </span><span class="si">%(fill)s</span><span class="s2">)</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">),</span>
    <span class="n">short_flx</span><span class="o">=</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">        masked_</span><span class="si">%(name)s</span><span class="s2">(data = </span><span class="si">%(data)s</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">%(nlen)s</span><span class="s2">        mask = </span><span class="si">%(mask)s</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">%(nlen)s</span><span class="s2">  fill_value = </span><span class="si">%(fill)s</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">%(nlen)s</span><span class="s2">       dtype = </span><span class="si">%(dtype)s</span><span class="s2">)</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">###############################################################################</span>
<span class="c1">#                          MaskedArray class                                  #</span>
<span class="c1">###############################################################################</span>


<span class="k">def</span> <span class="nf">_recursive_filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively fill `a` with `fill_value`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">_recursive_filled</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">mask</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">fill_value</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">flatten_structured_array</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flatten a structured array.</span>

<span class="sd">    The data type of the output is chosen such that it can represent all of the</span>
<span class="sd">    (nested) fields.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : structured array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : masked array or ndarray</span>
<span class="sd">        A flattened masked array if the input is a masked array, otherwise a</span>
<span class="sd">        standard ndarray.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ndtype = [(&#39;a&#39;, int), (&#39;b&#39;, float)]</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([(1, 1), (2, 2)], dtype=ndtype)</span>
<span class="sd">    &gt;&gt;&gt; flatten_structured_array(a)</span>
<span class="sd">    array([[1., 1.],</span>
<span class="sd">           [2., 2.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">flatten_sequence</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flattens a compound of nested iterables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">elm</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">elm</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">flatten_sequence</span><span class="p">(</span><span class="n">elm</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">elm</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">inishape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">flatten_sequence</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">])</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">flatten_sequence</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
                              <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">flatten_sequence</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">a</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inishape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">newshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inishape</span>
        <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">flatten_sequence</span><span class="p">(</span><span class="n">newshape</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_arraymethod</span><span class="p">(</span><span class="n">funcname</span><span class="p">,</span> <span class="n">onmask</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a class method wrapper around a basic array method.</span>

<span class="sd">    Creates a class method which returns a masked array, where the new</span>
<span class="sd">    ``_data`` array is the output of the corresponding basic method called</span>
<span class="sd">    on the original ``_data``.</span>

<span class="sd">    If `onmask` is True, the new mask is the output of the method called</span>
<span class="sd">    on the initial mask. Otherwise, the new mask is just a reference</span>
<span class="sd">    to the initial mask.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    funcname : str</span>
<span class="sd">        Name of the function to apply on data.</span>
<span class="sd">    onmask : bool</span>
<span class="sd">        Whether the mask must be processed also (True) or left</span>
<span class="sd">        alone (False). Default is True. Make available as `_onmask`</span>
<span class="sd">        attribute.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    method : instancemethod</span>
<span class="sd">        Class method wrapper of the specified basic array method.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">wrapped_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">funcname</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">onmask</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="c1"># __setmask__ makes a copy, which we don&#39;t want</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">funcname</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="n">methdoc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">methdoc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wrapped_method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">methdoc</span><span class="o">.</span><span class="vm">__doc__</span>
    <span class="n">wrapped_method</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">funcname</span>
    <span class="k">return</span> <span class="n">wrapped_method</span>


<span class="k">class</span> <span class="nc">MaskedIterator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flat iterator object to iterate over masked arrays.</span>

<span class="sd">    A `MaskedIterator` iterator is returned by ``x.flat`` for any masked array</span>
<span class="sd">    `x`. It allows iterating over the array as if it were a 1-D array,</span>
<span class="sd">    either in a for-loop or by calling its `next` method.</span>

<span class="sd">    Iteration is done in C-contiguous style, with the last index varying the</span>
<span class="sd">    fastest. The iterator can also be indexed using basic slicing or</span>
<span class="sd">    advanced indexing.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MaskedArray.flat : Return a flat iterator over an array.</span>
<span class="sd">    MaskedArray.flatten : Returns a flattened copy of an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `MaskedIterator` is not exported by the `ma` module. Instead of</span>
<span class="sd">    instantiating a `MaskedIterator` directly, use `MaskedArray.flat`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array(arange(6).reshape(2, 3))</span>
<span class="sd">    &gt;&gt;&gt; fl = x.flat</span>
<span class="sd">    &gt;&gt;&gt; type(fl)</span>
<span class="sd">    &lt;class &#39;numpy.ma.core.MaskedIterator&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; for item in fl:</span>
<span class="sd">    ...     print(item)</span>
<span class="sd">    ...</span>
<span class="sd">    0</span>
<span class="sd">    1</span>
<span class="sd">    2</span>
<span class="sd">    3</span>
<span class="sd">    4</span>
<span class="sd">    5</span>

<span class="sd">    Extracting more than a single element b indexing the `MaskedIterator`</span>
<span class="sd">    returns a masked array:</span>

<span class="sd">    &gt;&gt;&gt; fl[2:4]</span>
<span class="sd">    masked_array(data = [2 3],</span>
<span class="sd">                 mask = False,</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ma</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ma</span> <span class="o">=</span> <span class="n">ma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataiter</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">flat</span>

        <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">flat</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataiter</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># set shape to match that of data; this is needed for matrices</span>
                <span class="n">_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">mvoid</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_mask</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_mask</span><span class="p">:</span>  <span class="c1"># Just a scalar, masked</span>
                <span class="k">return</span> <span class="n">masked</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># This won&#39;t work if ravel makes a copy</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataiter</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the next value, or raise StopIteration.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([3, 2], mask=[0, 1])</span>
<span class="sd">        &gt;&gt;&gt; fl = x.flat</span>
<span class="sd">        &gt;&gt;&gt; fl.next()</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; fl.next()</span>
<span class="sd">        masked_array(data = --,</span>
<span class="sd">                     mask = True,</span>
<span class="sd">               fill_value = 1e+20)</span>
<span class="sd">        &gt;&gt;&gt; fl.next()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">          File &quot;/home/ralf/python/numpy/numpy/ma/core.py&quot;, line 2243, in next</span>
<span class="sd">            d = self.dataiter.next()</span>
<span class="sd">        StopIteration</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataiter</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">mvoid</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">m</span><span class="p">:</span>  <span class="c1"># Just a scalar, masked</span>
                <span class="k">return</span> <span class="n">masked</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nb">next</span> <span class="o">=</span> <span class="fm">__next__</span>


<span class="k">class</span> <span class="nc">MaskedArray</span><span class="p">(</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An array class with possibly masked values.</span>

<span class="sd">    Masked values of True exclude the corresponding element from any</span>
<span class="sd">    computation.</span>

<span class="sd">    Construction::</span>

<span class="sd">      x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,</span>
<span class="sd">                      ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,</span>
<span class="sd">                      shrink=True, order=None)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    mask : sequence, optional</span>
<span class="sd">        Mask. Must be convertible to an array of booleans with the same</span>
<span class="sd">        shape as `data`. True indicates a masked (i.e. invalid) data.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Data type of the output.</span>
<span class="sd">        If `dtype` is None, the type of the data argument (``data.dtype``)</span>
<span class="sd">        is used. If `dtype` is not None and different from ``data.dtype``,</span>
<span class="sd">        a copy is performed.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        Whether to copy the input data (True), or to use a reference instead.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    subok : bool, optional</span>
<span class="sd">        Whether to return a subclass of `MaskedArray` if possible (True) or a</span>
<span class="sd">        plain `MaskedArray`. Default is True.</span>
<span class="sd">    ndmin : int, optional</span>
<span class="sd">        Minimum number of dimensions. Default is 0.</span>
<span class="sd">    fill_value : scalar, optional</span>
<span class="sd">        Value used to fill in the masked values when necessary.</span>
<span class="sd">        If None, a default based on the data-type is used.</span>
<span class="sd">    keep_mask : bool, optional</span>
<span class="sd">        Whether to combine `mask` with the mask of the input data, if any</span>
<span class="sd">        (True), or to use only `mask` for the output (False). Default is True.</span>
<span class="sd">    hard_mask : bool, optional</span>
<span class="sd">        Whether to use a hard mask or not. With a hard mask, masked values</span>
<span class="sd">        cannot be unmasked. Default is False.</span>
<span class="sd">    shrink : bool, optional</span>
<span class="sd">        Whether to force compression of an empty mask. Default is True.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;}, optional</span>
<span class="sd">        Specify the order of the array.  If order is &#39;C&#39;, then the array</span>
<span class="sd">        will be in C-contiguous order (last-index varies the fastest).</span>
<span class="sd">        If order is &#39;F&#39;, then the returned array will be in</span>
<span class="sd">        Fortran-contiguous order (first-index varies the fastest).</span>
<span class="sd">        If order is &#39;A&#39; (default), then the returned array may be</span>
<span class="sd">        in any order (either C-, Fortran-contiguous, or even discontiguous),</span>
<span class="sd">        unless a copy is required, in which case it will be C-contiguous.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">15</span>
    <span class="n">_defaultmask</span> <span class="o">=</span> <span class="n">nomask</span>
    <span class="n">_defaulthardmask</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_baseclass</span> <span class="o">=</span> <span class="n">ndarray</span>

    <span class="c1"># Maximum number of elements per axis used when printing an array. The</span>
    <span class="c1"># 1d case is handled separately because we need more values in this case.</span>
    <span class="n">_print_width</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">_print_width_1d</span> <span class="o">=</span> <span class="mi">1500</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">nomask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">hard_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new masked array from scratch.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        A masked array can also be created by taking a .view(MaskedArray).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Process data.</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                         <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">)</span>
        <span class="n">_baseclass</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;_baseclass&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">_data</span><span class="p">))</span>
        <span class="c1"># Check that we&#39;re not erasing the mask.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Here, we copy the _view_, so that we can attach new properties to it</span>
        <span class="c1"># we must never do .view(MaskedConstant), as that would create a new</span>
        <span class="c1"># instance of np.ma.masked, which make identity comparison fail</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span> <span class="ow">and</span> <span class="n">subok</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">MaskedConstant</span><span class="p">):</span>
            <span class="n">_data</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_data</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
        <span class="c1"># Backwards compatibility w/ numpy.core.ma.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_mask</span>
            <span class="c1"># FIXME _sharedmask is never used.</span>
            <span class="n">_sharedmask</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Process mask.</span>
        <span class="c1"># Type of the mask</span>
        <span class="n">mdtype</span> <span class="o">=</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="c1"># Case 1. : no mask in input.</span>
            <span class="c1"># Erase the current mask ?</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_mask</span><span class="p">:</span>
                <span class="c1"># With a reduced version</span>
                <span class="k">if</span> <span class="n">shrink</span><span class="p">:</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">nomask</span>
                <span class="c1"># With full version</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
            <span class="c1"># Check whether we missed something</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># If data is a sequence of masked array</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">data</span><span class="p">],</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># If data is nested</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">nomask</span>
                <span class="c1"># Force shrinking of the mask if needed (and possible)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mdtype</span> <span class="o">==</span> <span class="n">MaskType</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_data</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">copy</span>
                <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="c1"># Reset the shape of the original mask</span>
                    <span class="k">if</span> <span class="n">getmask</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Case 2. : With a mask in input.</span>
            <span class="c1"># If mask is boolean, create an array of True or False</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">mdtype</span> <span class="o">==</span> <span class="n">MaskType</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">mdtype</span> <span class="o">==</span> <span class="n">MaskType</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Read the mask with the current mdtype</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
                <span class="c1"># Or assume it&#39;s a sequence of bool/int</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">tuple</span><span class="p">([</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdtype</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">],</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
            <span class="c1"># Make sure the mask and the data have the same shape</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">nm</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nm</span> <span class="o">==</span> <span class="n">nd</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Mask and data not compatible: data size is </span><span class="si">%i</span><span class="s2">, &quot;</span> <span class="o">+</span> \
                          <span class="s2">&quot;mask size is </span><span class="si">%i</span><span class="s2">.&quot;</span>
                    <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">nm</span><span class="p">))</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Set the mask to the new value</span>
            <span class="k">if</span> <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
                <span class="n">_data</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">copy</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_mask</span><span class="p">:</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">copy</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                        <span class="k">def</span> <span class="nf">_recursive_or</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                            <span class="s2">&quot;do a|=b on each field of a, recursively&quot;</span>
                            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                                <span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">bf</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                                <span class="k">if</span> <span class="n">af</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                                    <span class="n">_recursive_or</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">bf</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">af</span> <span class="o">|=</span> <span class="n">bf</span>

                        <span class="n">_recursive_or</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Update fill_value.</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;_fill_value&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># But don&#39;t run the check unless we have something to check.</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_data</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="n">_check_fill_value</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Process extra options ..</span>
        <span class="k">if</span> <span class="n">hard_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_data</span><span class="o">.</span><span class="n">_hardmask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;_hardmask&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_data</span><span class="o">.</span><span class="n">_hardmask</span> <span class="o">=</span> <span class="n">hard_mask</span>
        <span class="n">_data</span><span class="o">.</span><span class="n">_baseclass</span> <span class="o">=</span> <span class="n">_baseclass</span>
        <span class="k">return</span> <span class="n">_data</span>


    <span class="k">def</span> <span class="nf">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copies some attributes of obj to self.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="n">_baseclass</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_baseclass</span> <span class="o">=</span> <span class="n">ndarray</span>
        <span class="c1"># We need to copy the _basedict to avoid backward propagation</span>
        <span class="n">_optinfo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">_optinfo</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_optinfo&#39;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="n">_optinfo</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_basedict&#39;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">_optinfo</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="n">_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_fill_value</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_fill_value&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="n">_hardmask</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_hardmask&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                     <span class="n">_sharedmask</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_sharedmask&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                     <span class="n">_isfield</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_isfield&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                     <span class="n">_baseclass</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_baseclass&#39;</span><span class="p">,</span> <span class="n">_baseclass</span><span class="p">),</span>
                     <span class="n">_optinfo</span><span class="o">=</span><span class="n">_optinfo</span><span class="p">,</span>
                     <span class="n">_basedict</span><span class="o">=</span><span class="n">_optinfo</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_optinfo</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finalizes the masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get main attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="c1"># We have to decide how to initialize self.mask, based on</span>
        <span class="c1"># obj.mask. This is very difficult.  There might be some</span>
        <span class="c1"># correspondence between the elements in the array we are being</span>
        <span class="c1"># created from (= obj) and us. Or there might not. This method can</span>
        <span class="c1"># be called in all kinds of places for all kinds of reasons -- could</span>
        <span class="c1"># be empty_like, could be slicing, could be a ufunc, could be a view.</span>
        <span class="c1"># The numpy subclassing interface simply doesn&#39;t give us any way</span>
        <span class="c1"># to know, which means that at best this method will be based on</span>
        <span class="c1"># guesswork and heuristics. To make things worse, there isn&#39;t even any</span>
        <span class="c1"># clear consensus about what the desired behavior is. For instance,</span>
        <span class="c1"># most users think that np.empty_like(marr) -- which goes via this</span>
        <span class="c1"># method -- should return a masked array with an empty mask (see</span>
        <span class="c1"># gh-3404 and linked discussions), but others disagree, and they have</span>
        <span class="c1"># existing code which depends on empty_like returning an array that</span>
        <span class="c1"># matches the input mask.</span>
        <span class="c1">#</span>
        <span class="c1"># Historically our algorithm was: if the template object mask had the</span>
        <span class="c1"># same *number of elements* as us, then we used *it&#39;s mask object</span>
        <span class="c1"># itself* as our mask, so that writes to us would also write to the</span>
        <span class="c1"># original array. This is horribly broken in multiple ways.</span>
        <span class="c1">#</span>
        <span class="c1"># Now what we do instead is, if the template object mask has the same</span>
        <span class="c1"># number of elements as us, and we do not have the same base pointer</span>
        <span class="c1"># as the template object (b/c views like arr[...] should keep the same</span>
        <span class="c1"># mask), then we make a copy of the template object mask and use</span>
        <span class="c1"># that. This is also horribly broken but somewhat less so. Maybe.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># XX: This looks like a bug -- shouldn&#39;t it check self.dtype</span>
            <span class="c1"># instead?</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

            <span class="c1"># If self and obj point to exactly the same data, then probably</span>
            <span class="c1"># self is a simple view of obj (e.g., self = obj[...]), so they</span>
            <span class="c1"># should share the same mask. (This isn&#39;t 100% reliable, e.g. self</span>
            <span class="c1"># could be the first row of obj, or have strange strides, but as a</span>
            <span class="c1"># heuristic it&#39;s not bad.) In all other cases, we make a copy of</span>
            <span class="c1"># the mask, so that future modifications to &#39;self&#39; do not end up</span>
            <span class="c1"># side-effecting &#39;obj&#39; as well.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">obj</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1"># We should make a copy. But we could get here via astype,</span>
                <span class="c1"># in which case the mask might need a new dtype as well</span>
                <span class="c1"># (e.g., changing to or from a structured dtype), and the</span>
                <span class="c1"># order could have changed. So, change the mask type if</span>
                <span class="c1"># needed and use astype instead of copy.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                    <span class="n">_mask_dtype</span> <span class="o">=</span> <span class="n">_mask</span><span class="o">.</span><span class="n">dtype</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_mask_dtype</span> <span class="o">=</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;K&quot;</span>

                <span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_mask_dtype</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Take a view so shape changes, etc., do not propagate back.</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_mask</span> <span class="o">=</span> <span class="n">nomask</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span>
        <span class="c1"># Finalize the mask</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">nomask</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="c1"># When _mask.shape is not writable (because it&#39;s a void)</span>
                <span class="k">pass</span>
        <span class="c1"># Finalize the fill_value for structured arrays</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="n">_check_fill_value</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Special hook for ufuncs.</span>

<span class="sd">        Wraps the numpy array and sets the mask according to context.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># for in-place operations</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">out_i</span> <span class="o">=</span> <span class="n">context</span>
            <span class="c1"># args sometimes contains outputs (gh-10459), which we don&#39;t want</span>
            <span class="n">input_args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="n">func</span><span class="o">.</span><span class="n">nin</span><span class="p">]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">mask_or</span><span class="p">,</span> <span class="p">[</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">input_args</span><span class="p">])</span>
            <span class="c1"># Get the domain mask</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="n">ufunc_domain</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Take the domain, and make sure it&#39;s a ndarray</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">domain</span><span class="p">(</span><span class="o">*</span><span class="n">input_args</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="c1"># Fill the result where the domain is wrong</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Binary domain: take the last value</span>
                        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">func</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="c1"># Unary domain: just use this one</span>
                        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">func</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="c1"># Domain not recognized, use fill_value instead</span>
                        <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>

                    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>

                    <span class="c1"># Update the mask</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Don&#39;t modify inplace, we risk back-propagation</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">|</span> <span class="n">d</span><span class="p">)</span>

            <span class="c1"># Make sure the mask has the proper size</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">masked</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a view of the MaskedArray data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : data-type or ndarray sub-class, optional</span>
<span class="sd">            Data-type descriptor of the returned view, e.g., float32 or int16.</span>
<span class="sd">            The default, None, results in the view having the same data-type</span>
<span class="sd">            as `a`. As with ``ndarray.view``, dtype can also be specified as</span>
<span class="sd">            an ndarray sub-class, which then specifies the type of the</span>
<span class="sd">            returned object (this is equivalent to setting the ``type``</span>
<span class="sd">            parameter).</span>
<span class="sd">        type : Python type, optional</span>
<span class="sd">            Type of the returned view, either ndarray or a subclass.  The</span>
<span class="sd">            default None results in type preservation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        ``a.view()`` is used two different ways:</span>

<span class="sd">        ``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view</span>
<span class="sd">        of the array&#39;s memory with a different data-type.  This can cause a</span>
<span class="sd">        reinterpretation of the bytes of memory.</span>

<span class="sd">        ``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just</span>
<span class="sd">        returns an instance of `ndarray_subclass` that looks at the same array</span>
<span class="sd">        (same shape, dtype, etc.)  This does not cause a reinterpretation of the</span>
<span class="sd">        memory.</span>

<span class="sd">        If `fill_value` is not specified, but `dtype` is specified (and is not</span>
<span class="sd">        an ndarray sub-class), the `fill_value` of the MaskedArray will be</span>
<span class="sd">        reset. If neither `fill_value` nor `dtype` are specified (or if</span>
<span class="sd">        `dtype` is an ndarray sub-class), then the fill value is preserved.</span>
<span class="sd">        Finally, if `fill_value` is specified, but `dtype` is not, the fill</span>
<span class="sd">        value is set to the specified value.</span>

<span class="sd">        For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of</span>
<span class="sd">        bytes per entry than the previous dtype (for example, converting a</span>
<span class="sd">        regular array to a structured array), then the behavior of the view</span>
<span class="sd">        cannot be predicted just from the superficial appearance of ``a`` (shown</span>
<span class="sd">        by ``print(a)``). It also depends on exactly how ``a`` is stored in</span>
<span class="sd">        memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus</span>
<span class="sd">        defined as a slice or transpose, etc., the view may give different</span>
<span class="sd">        results.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">output</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

        <span class="c1"># also make the mask be a view (so attr changes to the view&#39;s</span>
        <span class="c1"># mask do no affect original object&#39;s mask)</span>
        <span class="c1"># (especially important to avoid affecting np.masked singleton)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">getmask</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">):</span>
            <span class="n">output</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

        <span class="c1"># Make sure to reset the _fill_value if needed</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s1">&#39;_fill_value&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">pass</span>  <span class="c1"># leave _fill_value as is</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">return</span> <span class="n">output</span>
    <span class="n">view</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        x.__getitem__(y) &lt;==&gt; x[y]</span>

<span class="sd">        Return the item described by i, as a masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We could directly use ndarray.__getitem__ on self.</span>
        <span class="c1"># But then we would have to modify __array_finalize__ to prevent the</span>
        <span class="c1"># mask of being reshaped if it hasn&#39;t been set up properly yet</span>
        <span class="c1"># So it&#39;s easier to stick to the current version</span>
        <span class="n">dout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>

        <span class="k">def</span> <span class="nf">_is_scalar</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_scalar_heuristic</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return whether `elem` is a scalar result of indexing `arr`, or None</span>
<span class="sd">            if undecidable without promoting nomask to a full mask</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># obviously a scalar</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># object array scalar indexing can return anything</span>
            <span class="k">elif</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">elem</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                    <span class="c1"># elem is an array, but dtypes do not match, so must be</span>
                    <span class="c1"># an element</span>
                    <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># well-behaved subclass that only returns 0d arrays when</span>
            <span class="c1"># expected - this is not a scalar</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span> <span class="o">==</span> <span class="n">ndarray</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="c1"># _mask cannot be a subclass, so it tells us whether we should</span>
            <span class="c1"># expect a scalar. It also cannot be of dtype object.</span>
            <span class="n">mout</span> <span class="o">=</span> <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
            <span class="n">scalar_expected</span> <span class="o">=</span> <span class="n">_is_scalar</span><span class="p">(</span><span class="n">mout</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># attempt to apply the heuristic to avoid constructing a full mask</span>
            <span class="n">mout</span> <span class="o">=</span> <span class="n">nomask</span>
            <span class="n">scalar_expected</span> <span class="o">=</span> <span class="n">_scalar_heuristic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dout</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scalar_expected</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># heuristics have failed</span>
                <span class="c1"># construct a full array, so we can be certain. This is costly.</span>
                <span class="c1"># we could also fall back on ndarray.__getitem__(self.data, indx)</span>
                <span class="n">scalar_expected</span> <span class="o">=</span> <span class="n">_is_scalar</span><span class="p">(</span><span class="n">getmaskarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="n">indx</span><span class="p">])</span>

        <span class="c1"># Did we extract a single item?</span>
        <span class="k">if</span> <span class="n">scalar_expected</span><span class="p">:</span>
            <span class="c1"># A record</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">):</span>
                <span class="c1"># We should always re-cast to mvoid, otherwise users can</span>
                <span class="c1"># change masks on rows that already have masked values, but not</span>
                <span class="c1"># on rows that have no masked values, which is inconsistent.</span>
                <span class="k">return</span> <span class="n">mvoid</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mout</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">)</span>

            <span class="c1"># special case introduced in gh-5962</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span> <span class="ow">and</span>
                  <span class="nb">isinstance</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="n">dout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">masked</span><span class="p">):</span>
                <span class="c1"># If masked, turn into a MaskedArray, with everything masked.</span>
                <span class="k">if</span> <span class="n">mout</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">MaskedArray</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">dout</span>

            <span class="c1"># Just a scalar</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mout</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">masked</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">dout</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Force dout to MA</span>
            <span class="n">dout</span> <span class="o">=</span> <span class="n">dout</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="c1"># Inherit attributes from self</span>
            <span class="n">dout</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="c1"># Check the fill_value</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dout</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>

                    <span class="c1"># If we&#39;re indexing a multidimensional field in a</span>
                    <span class="c1"># structured array (such as dtype(&quot;(2,)i2,(2,)i1&quot;)),</span>
                    <span class="c1"># dimensionality goes up (M[field].ndim == M.ndim +</span>
                    <span class="c1"># M.dtype[field].ndim).  That&#39;s fine for</span>
                    <span class="c1"># M[field] but problematic for M[field].fill_value</span>
                    <span class="c1"># which should have shape () to avoid breaking several</span>
                    <span class="c1"># methods. There is no great way out, so set to</span>
                    <span class="c1"># first element.  See issue #6723.</span>
                    <span class="k">if</span> <span class="n">dout</span><span class="o">.</span><span class="n">_fill_value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dout</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">==</span>
                                <span class="n">dout</span><span class="o">.</span><span class="n">_fill_value</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                                <span class="s2">&quot;Upon accessing multidimensional field &quot;</span>
                                <span class="s2">&quot;</span><span class="si">{indx:s}</span><span class="s2">, need to keep dimensionality &quot;</span>
                                <span class="s2">&quot;of fill_value at 0. Discarding &quot;</span>
                                <span class="s2">&quot;heterogeneous fill_value and setting &quot;</span>
                                <span class="s2">&quot;all to </span><span class="si">{fv!s}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indx</span><span class="o">=</span><span class="n">indx</span><span class="p">,</span>
                                    <span class="n">fv</span><span class="o">=</span><span class="n">dout</span><span class="o">.</span><span class="n">_fill_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">dout</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="n">dout</span><span class="o">.</span><span class="n">_fill_value</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dout</span><span class="o">.</span><span class="n">_isfield</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Update the mask if needed</span>
            <span class="k">if</span> <span class="n">mout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="c1"># set shape to match that of data; this is needed for matrices</span>
                <span class="n">dout</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">mout</span><span class="p">,</span> <span class="n">dout</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">dout</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Note: Don&#39;t try to check for m.any(), that&#39;ll take too long</span>
        <span class="k">return</span> <span class="n">dout</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        x.__setitem__(i, y) &lt;==&gt; x[i]=y</span>

<span class="sd">        Set item described by index. If value is masked, masks those</span>
<span class="sd">        locations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="s1">&#39;Cannot alter the masked element.&#39;</span><span class="p">)</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">_dtype</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">nbfields</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">or</span> <span class="p">())</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="c1"># The mask wasn&#39;t set: create a full version.</span>
            <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">)</span>
            <span class="c1"># Now, set the mask to its value.</span>
            <span class="k">if</span> <span class="n">nbfields</span><span class="p">:</span>
                <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbfields</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>

        <span class="c1"># Get the _data part of the new value</span>
        <span class="n">dval</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;_data&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># Get the _mask part of the new value</span>
        <span class="n">mval</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nbfields</span> <span class="ow">and</span> <span class="n">mval</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">mval</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbfields</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="c1"># Set the data, then the mask</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dval</span>
            <span class="k">if</span> <span class="n">mval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">)</span>
                <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mval</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">:</span>
            <span class="c1"># Set the data, then the mask</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dval</span>
            <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mval</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">indx</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">MaskType</span><span class="p">):</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">indx</span> <span class="o">*</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">_mask</span><span class="p">)</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nbfields</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Flexible &#39;hard&#39; masks are not yet supported.&quot;</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
            <span class="n">mindx</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="n">mval</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">dindx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dindx</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">dindx</span><span class="p">,</span> <span class="n">dval</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">mindx</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mindx</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">dindx</span> <span class="o">=</span> <span class="n">dval</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dindx</span>
            <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mindx</span>
        <span class="k">return</span>

    <span class="c1"># Define so that we can overwrite the setter.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@dtype</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">make_mask_descr</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span> <span class="n">ndarray</span><span class="p">)</span>
            <span class="c1"># Try to reset the shape of the mask (if we don&#39;t have a void).</span>
            <span class="c1"># This raises a ValueError if the dtype change won&#39;t work.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@shape</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Cannot use self._mask, since it may not (yet) exist when a</span>
        <span class="c1"># masked matrix sets the shape.</span>
        <span class="k">if</span> <span class="n">getmask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">def</span> <span class="nf">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">current_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">current_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
            <span class="c1"># Make sure the mask is set</span>
            <span class="c1"># Just don&#39;t do anything if there&#39;s nothing to do.</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">current_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">idtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">idtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No named fields.</span>
            <span class="c1"># Hardmask: don&#39;t unmask the data</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">:</span>
                <span class="n">current_mask</span> <span class="o">|=</span> <span class="n">mask</span>
            <span class="c1"># Softmask: set everything to False</span>
            <span class="c1"># If it&#39;s obviously a compatible scalar, use a quick update</span>
            <span class="c1"># method.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)):</span>
                <span class="n">current_mask</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="c1"># Otherwise fall back to the slower, general purpose way.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_mask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Named fields w/</span>
            <span class="n">mdtype</span> <span class="o">=</span> <span class="n">current_mask</span><span class="o">.</span><span class="n">dtype</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Mask is a singleton</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="c1"># It&#39;s a boolean : make a record</span>
                <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">mask</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdtype</span><span class="p">)),</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
                <span class="c1"># It&#39;s a record: make sure the dtype is correct</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mdtype</span><span class="p">)</span>
            <span class="c1"># Mask is a sequence</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Make sure the new mask is a ndarray with the proper dtype</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
                <span class="c1"># Or assume it&#39;s a sequence of bool/int</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">tuple</span><span class="p">([</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdtype</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">],</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
            <span class="c1"># Hardmask: don&#39;t unmask the data</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">idtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="n">current_mask</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="c1"># Softmask: set everything to False</span>
            <span class="c1"># If it&#39;s obviously a compatible scalar, use a quick update</span>
            <span class="c1"># method.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)):</span>
                <span class="n">current_mask</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="c1"># Otherwise fall back to the slower, general purpose way.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_mask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="c1"># Reshape if needed</span>
        <span class="k">if</span> <span class="n">current_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">current_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span>

    <span class="n">_set_mask</span> <span class="o">=</span> <span class="n">__setmask__</span>

    <span class="k">def</span> <span class="nf">_get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the current mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We could try to force a reshape, but that wouldn&#39;t work in some</span>
        <span class="c1"># cases.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_mask</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">__setmask__</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Mask&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_recordmask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mask of the records.</span>

<span class="sd">        A record is masked when all the fields are masked.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_mask</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flatten_structured_array</span><span class="p">(</span><span class="n">_mask</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_recordmask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mask of the records.</span>

<span class="sd">        A record is masked when all the fields are masked.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Coming soon: setting the mask per records!&quot;</span><span class="p">)</span>

    <span class="n">recordmask</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_recordmask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">harden_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Force the mask to hard.</span>

<span class="sd">        Whether the mask of a masked array is hard or soft is determined by</span>
<span class="sd">        its `hardmask` property. `harden_mask` sets `hardmask` to True.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hardmask</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">soften_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Force the mask to soft.</span>

<span class="sd">        Whether the mask of a masked array is hard or soft is determined by</span>
<span class="sd">        its `hardmask` property. `soften_mask` sets `hardmask` to False.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hardmask</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">hardmask</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">,</span>
                        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Hardness of the mask&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unshare_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy the mask and set the sharedmask flag to False.</span>

<span class="sd">        Whether the mask is shared between masked arrays can be seen from</span>
<span class="sd">        the `sharedmask` property. `unshare_mask` ensures the mask is not shared.</span>
<span class="sd">        A copy of the mask is only made if it was shared.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sharedmask</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sharedmask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">sharedmask</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sharedmask</span><span class="p">,</span>
                          <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Share status of the mask (read-only).&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shrink_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduce a mask to nomask when possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)</span>
<span class="sd">        &gt;&gt;&gt; x.mask</span>
<span class="sd">        array([[False, False],</span>
<span class="sd">               [False, False]])</span>
<span class="sd">        &gt;&gt;&gt; x.shrink_mask()</span>
<span class="sd">        &gt;&gt;&gt; x.mask</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_shrink_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">baseclass</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseclass</span><span class="p">,</span>
                         <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Class of the underlying data (read-only).&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the current data, as a view of the original</span>
<span class="sd">        underlying data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseclass</span><span class="p">)</span>

    <span class="n">_data</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_data</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return a flat iterator.&quot;</span>
        <span class="k">return</span> <span class="n">MaskedIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="s2">&quot;Set a flattened version of self to value.&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">flat</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_flat</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_flat</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Flat version of the array.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the filling value of the masked array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fill_value : scalar</span>
<span class="sd">            The filling value.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; for dt in [np.int32, np.int64, np.float64, np.complex128]:</span>
<span class="sd">        ...     np.ma.array([0, 1], dtype=dt).get_fill_value()</span>
<span class="sd">        ...</span>
<span class="sd">        999999</span>
<span class="sd">        999999</span>
<span class="sd">        1e+20</span>
<span class="sd">        (1e+20+0j)</span>

<span class="sd">        &gt;&gt;&gt; x = np.ma.array([0, 1.], fill_value=-np.inf)</span>
<span class="sd">        &gt;&gt;&gt; x.get_fill_value()</span>
<span class="sd">        -inf</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="n">_check_fill_value</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Temporary workaround to account for the fact that str and bytes</span>
        <span class="c1"># scalars cannot be indexed with (), whereas all other numpy</span>
        <span class="c1"># scalars can. See issues #7259 and #7267.</span>
        <span class="c1"># The if-block can be removed after #7267 has been fixed.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span>

    <span class="k">def</span> <span class="nf">set_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the filling value of the masked array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, optional</span>
<span class="sd">            The new filling value. Default is None, in which case a default</span>
<span class="sd">            based on the data type is used.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ma.set_fill_value : Equivalent function.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([0, 1.], fill_value=-np.inf)</span>
<span class="sd">        &gt;&gt;&gt; x.fill_value</span>
<span class="sd">        -inf</span>
<span class="sd">        &gt;&gt;&gt; x.set_fill_value(np.pi)</span>
<span class="sd">        &gt;&gt;&gt; x.fill_value</span>
<span class="sd">        3.1415926535897931</span>

<span class="sd">        Reset to default:</span>

<span class="sd">        &gt;&gt;&gt; x.set_fill_value()</span>
<span class="sd">        &gt;&gt;&gt; x.fill_value</span>
<span class="sd">        1e+20</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_check_fill_value</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">_fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span>
        <span class="k">if</span> <span class="n">_fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create the attribute if it was undefined</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="n">target</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Don&#39;t overwrite the attribute, just fill it (for propagation)</span>
            <span class="n">_fill_value</span><span class="p">[()]</span> <span class="o">=</span> <span class="n">target</span>

    <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">get_fill_value</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">set_fill_value</span><span class="p">,</span>
                          <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Filling value.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of self, with masked values filled with a given value.</span>
<span class="sd">        **However**, if there are no masked values to fill, self will be</span>
<span class="sd">        returned instead as an ndarray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fill_value : scalar, optional</span>
<span class="sd">            The value to use for invalid entries (None by default).</span>
<span class="sd">            If None, the `fill_value` attribute of the array is used instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filled_array : ndarray</span>
<span class="sd">            A copy of ``self`` with invalid entries replaced by *fill_value*</span>
<span class="sd">            (be it the function argument or the attribute of ``self``), or</span>
<span class="sd">            ``self`` itself as an ndarray if there are no invalid entries to</span>
<span class="sd">            be replaced.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The result is **not** a MaskedArray!</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)</span>
<span class="sd">        &gt;&gt;&gt; x.filled()</span>
<span class="sd">        array([1, 2, -999, 4, -999])</span>
<span class="sd">        &gt;&gt;&gt; type(x.filled())</span>
<span class="sd">        &lt;type &#39;numpy.ndarray&#39;&gt;</span>

<span class="sd">        Subclassing is preserved. This means that if, e.g., the data part of</span>
<span class="sd">        the masked array is a recarray, `filled` returns a recarray:</span>

<span class="sd">        &gt;&gt;&gt; x = np.array([(-1, 2), (-3, 4)], dtype=&#39;i8,i8&#39;).view(np.recarray)</span>
<span class="sd">        &gt;&gt;&gt; m = np.ma.array(x, mask=[(True, False), (False, True)])</span>
<span class="sd">        &gt;&gt;&gt; m.filled()</span>
<span class="sd">        rec.array([(999999,      2), (    -3, 999999)],</span>
<span class="sd">                  dtype=[(&#39;f0&#39;, &#39;&lt;i8&#39;), (&#39;f1&#39;, &#39;&lt;i8&#39;)])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_check_fill_value</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">masked_singleton</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
            <span class="n">_recursive_filled</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">narray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="c1"># ok, if scalar</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="k">elif</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">compressed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all the non-masked data as a 1-D array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : ndarray</span>
<span class="sd">            A new `ndarray` holding the non-masked data is returned.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The result is **not** a MaskedArray!</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)</span>
<span class="sd">        &gt;&gt;&gt; x.compressed()</span>
<span class="sd">        array([0, 1])</span>
<span class="sd">        &gt;&gt;&gt; type(x.compressed())</span>
<span class="sd">        &lt;type &#39;numpy.ndarray&#39;&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">ndarray</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return `a` where condition is ``True``.</span>

<span class="sd">        If condition is a `MaskedArray`, missing values are considered</span>
<span class="sd">        as ``False``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        condition : var</span>
<span class="sd">            Boolean 1-d array selecting which entries to return. If len(condition)</span>
<span class="sd">            is less than the size of a along the axis, then output is truncated</span>
<span class="sd">            to length of condition array.</span>
<span class="sd">        axis : {None, int}, optional</span>
<span class="sd">            Axis along which the operation must be performed.</span>
<span class="sd">        out : {None, ndarray}, optional</span>
<span class="sd">            Alternative output array in which to place the result. It must have</span>
<span class="sd">            the same shape as the expected output but the type will be cast if</span>
<span class="sd">            necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : MaskedArray</span>
<span class="sd">            A :class:`MaskedArray` object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Please note the difference with :meth:`compressed` !</span>
<span class="sd">        The output of :meth:`compress` has a mask, the output of</span>
<span class="sd">        :meth:`compressed` does not.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[1 -- 3]</span>
<span class="sd">         [-- 5 --]</span>
<span class="sd">         [7 -- 9]]</span>
<span class="sd">        &gt;&gt;&gt; x.compress([1, 0, 1])</span>
<span class="sd">        masked_array(data = [1 3],</span>
<span class="sd">              mask = [False False],</span>
<span class="sd">              fill_value=999999)</span>

<span class="sd">        &gt;&gt;&gt; x.compress([1, 0, 1], axis=1)</span>
<span class="sd">        masked_array(data =</span>
<span class="sd">         [[1 3]</span>
<span class="sd">         [-- --]</span>
<span class="sd">         [7 9]],</span>
<span class="sd">              mask =</span>
<span class="sd">         [[False False]</span>
<span class="sd">         [ True  True]</span>
<span class="sd">         [False False]],</span>
<span class="sd">              fill_value=999999)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the basic components</span>
        <span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="n">_mask</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>

        <span class="c1"># Force the condition to a regular ndarray and forget the missing</span>
        <span class="c1"># values.</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">_new</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">_new</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">_new</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_new</span>

    <span class="k">def</span> <span class="nf">_insert_masked_print</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace masked values with masked_print_option, casting all innermost</span>
<span class="sd">        dtypes to object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">masked_print_option</span><span class="o">.</span><span class="n">enabled</span><span class="p">():</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># convert to object array to make filled work</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
                <span class="c1"># For big arrays, to avoid a costly conversion to the</span>
                <span class="c1"># object dtype, extract the corners before the conversion.</span>
                <span class="n">print_width</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_print_width</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span>
                               <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_width_1d</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">print_width</span><span class="p">:</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">print_width</span> <span class="o">//</span> <span class="mi">2</span>
                        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="o">-</span><span class="n">ind</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="o">-</span><span class="n">ind</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

                <span class="n">rdtype</span> <span class="o">=</span> <span class="n">_replace_dtype_fields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">rdtype</span><span class="p">)</span>
                <span class="n">_recursive_printoption</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">masked_print_option</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_insert_masked_print</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_insert_masked_print</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Literal string representation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseclass</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;array&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseclass</span><span class="o">.</span><span class="vm">__name__</span>


        <span class="c1"># 2016-11-19: Demoted to legacy format</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()[</span><span class="s1">&#39;legacy&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
            <span class="n">is_long</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">nlen</span><span class="o">=</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
                <span class="n">data</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                <span class="n">mask</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">),</span>
                <span class="n">fill</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">is_structured</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s1">&#39;long&#39;</span> <span class="k">if</span> <span class="n">is_long</span> <span class="k">else</span> <span class="s1">&#39;short&#39;</span><span class="p">,</span>
                <span class="s1">&#39;flx&#39;</span> <span class="k">if</span> <span class="n">is_structured</span> <span class="k">else</span> <span class="s1">&#39;std&#39;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">_legacy_print_templates</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">%</span> <span class="n">parameters</span>

        <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;masked_</span><span class="si">{}</span><span class="s1">(&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">dtype_needed</span> <span class="o">=</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">arrayprint</span><span class="o">.</span><span class="n">dtype_is_implied</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">or</span>
            <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="ow">or</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">)</span>

        <span class="c1"># determine which keyword args need to be shown</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">,</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dtype_needed</span><span class="p">:</span>
            <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">)</span>

        <span class="c1"># array has only one row (non-column)</span>
        <span class="n">is_one_row</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># choose what to indent each keyword with</span>
        <span class="n">min_indent</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">is_one_row</span><span class="p">:</span>
            <span class="c1"># first key on the same line as the type, remaining keys</span>
            <span class="c1"># aligned by equals</span>
            <span class="n">indents</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">indents</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prefix</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">builtins</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">min_indent</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="n">indents</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">n</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># absorbed into the first indent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># each key on its own line, indented by two spaces</span>
            <span class="n">indents</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">min_indent</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>  <span class="c1"># first key on the next line</span>

        <span class="c1"># format the field values</span>
        <span class="n">reprs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">reprs</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insert_masked_print</span><span class="p">(),</span>
            <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="n">indents</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;data=&#39;</span><span class="p">,</span>
            <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="n">reprs</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span>
            <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="n">indents</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;mask=&#39;</span><span class="p">,</span>
            <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="n">reprs</span><span class="p">[</span><span class="s1">&#39;fill_value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtype_needed</span><span class="p">:</span>
            <span class="n">reprs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">arrayprint</span><span class="o">.</span><span class="n">dtype_short_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># join keys with values and indentations</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indents</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">reprs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">result</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>

    <span class="k">def</span> <span class="nf">_delegate_binop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># This emulates the logic in</span>
        <span class="c1">#     private/binop_override.h:forward_binop_should_defer</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">array_ufunc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;__array_ufunc__&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">array_ufunc</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">other_priority</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;__array_priority__&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1000000</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_priority__</span> <span class="o">&lt;</span> <span class="n">other_priority</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If array_ufunc is not None, it will be called inside the ufunc;</span>
            <span class="c1"># None explicitly tells us to not call the ufunc, i.e., defer.</span>
            <span class="k">return</span> <span class="n">array_ufunc</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">compare</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare self with other using operator.eq or operator.ne.</span>

<span class="sd">        When either of the elements is masked, the result is masked as well,</span>
<span class="sd">        but the underlying boolean data are still set, with self and other</span>
<span class="sd">        considered equal if both are masked, and unequal otherwise.</span>

<span class="sd">        For structured arrays, all fields are combined, with masked values</span>
<span class="sd">        ignored. The result is masked if all fields were masked, with self</span>
<span class="sd">        and other considered equal only if both were fully masked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">omask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">smask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">smask</span><span class="p">,</span> <span class="n">omask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">odata</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="c1"># For possibly masked structured arrays we need to be careful,</span>
            <span class="c1"># since the standard structured array comparison will use all</span>
            <span class="c1"># fields, masked or not. To avoid masked fields influencing the</span>
            <span class="c1"># outcome, we set all masked fields in self to other, so they&#39;ll</span>
            <span class="c1"># count as equal.  To prepare, we ensure we have the right shape.</span>
            <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">odata</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">sbroadcast</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sbroadcast</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="n">sdata</span> <span class="o">=</span> <span class="n">sbroadcast</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">odata</span><span class="p">)</span>
            <span class="c1"># Now take care of the mask; the merged mask should have an item</span>
            <span class="c1"># masked if all fields were masked (in one and/or other).</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((),</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For regular arrays, just use the data as they come.</span>
            <span class="n">sdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="n">check</span> <span class="o">=</span> <span class="n">compare</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="n">odata</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">masked</span> <span class="k">if</span> <span class="n">mask</span> <span class="k">else</span> <span class="n">check</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="c1"># Adjust elements that were masked, which should be treated</span>
            <span class="c1"># as equal if masked in both, unequal if masked in one.</span>
            <span class="c1"># Note that this works automatically for structured arrays too.</span>
            <span class="n">check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">compare</span><span class="p">(</span><span class="n">smask</span><span class="p">,</span> <span class="n">omask</span><span class="p">),</span> <span class="n">check</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">check</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="c1"># Guarantee consistency of the shape, making a copy since the</span>
                <span class="c1"># the mask may need to get written to later.</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">check</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">check</span> <span class="o">=</span> <span class="n">check</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">check</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">check</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="n">check</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether other equals self elementwise.</span>

<span class="sd">        When either of the elements is masked, the result is masked as well,</span>
<span class="sd">        but the underlying boolean data are still set, with self and other</span>
<span class="sd">        considered equal if both are masked, and unequal otherwise.</span>

<span class="sd">        For structured arrays, all fields are combined, with masked values</span>
<span class="sd">        ignored. The result is masked if all fields were masked, with self</span>
<span class="sd">        and other considered equal only if both were fully masked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comparison</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether other does not equal self elementwise.</span>

<span class="sd">        When either of the elements is masked, the result is masked as well,</span>
<span class="sd">        but the underlying boolean data are still set, with self and other</span>
<span class="sd">        considered equal if both are masked, and unequal otherwise.</span>

<span class="sd">        For structured arrays, all fields are combined, with masked values</span>
<span class="sd">        ignored. The result is masked if all fields were masked, with self</span>
<span class="sd">        and other considered equal only if both were fully masked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comparison</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add self to other, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add other to self, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In analogy with __rsub__ and __rdiv__, use original order:</span>
        <span class="c1"># we get here from `other + self`.</span>
        <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract other from self, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract self from other, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="s2">&quot;Multiply self by other, and return a new masked array.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply other by self, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In analogy with __rsub__ and __rdiv__, use original order:</span>
        <span class="c1"># we get here from `other * self`.</span>
        <span class="k">return</span> <span class="n">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide other into self, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide other into self, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">true_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide self into other, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">true_divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide other into self, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide self into other, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">floor_divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise self to the power other, masking the potential NaNs/Infs</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise other to the power self, masking the potential NaNs/Infs</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add other to self in-place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                                     <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract other from self in-place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="k">elif</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__isub__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                                     <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply self by other in-place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="k">elif</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__imul__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                     <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__idiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide self by other in-place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_data</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">dom_mask</span> <span class="o">=</span> <span class="n">_DomainSafeDivide</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other_data</span><span class="p">)</span>
        <span class="n">other_mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">new_mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">other_mask</span><span class="p">,</span> <span class="n">dom_mask</span><span class="p">)</span>
        <span class="c1"># The following 3 lines control the domain filling</span>
        <span class="k">if</span> <span class="n">dom_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="o">=</span> <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">]</span>
            <span class="n">other_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dom_mask</span><span class="p">,</span> <span class="n">fval</span><span class="p">,</span> <span class="n">other_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">|=</span> <span class="n">new_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__idiv__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                     <span class="n">other_data</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__ifloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Floor divide self by other in-place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_data</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">dom_mask</span> <span class="o">=</span> <span class="n">_DomainSafeDivide</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other_data</span><span class="p">)</span>
        <span class="n">other_mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">new_mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">other_mask</span><span class="p">,</span> <span class="n">dom_mask</span><span class="p">)</span>
        <span class="c1"># The following 3 lines control the domain filling</span>
        <span class="k">if</span> <span class="n">dom_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="o">=</span> <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">]</span>
            <span class="n">other_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dom_mask</span><span class="p">,</span> <span class="n">fval</span><span class="p">,</span> <span class="n">other_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">|=</span> <span class="n">new_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__ifloordiv__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                          <span class="n">other_data</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True divide self by other in-place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_data</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">dom_mask</span> <span class="o">=</span> <span class="n">_DomainSafeDivide</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other_data</span><span class="p">)</span>
        <span class="n">other_mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">new_mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">other_mask</span><span class="p">,</span> <span class="n">dom_mask</span><span class="p">)</span>
        <span class="c1"># The following 3 lines control the domain filling</span>
        <span class="k">if</span> <span class="n">dom_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="o">=</span> <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">]</span>
            <span class="n">other_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dom_mask</span><span class="p">,</span> <span class="n">fval</span><span class="p">,</span> <span class="n">other_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">|=</span> <span class="n">new_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__itruediv__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                         <span class="n">other_data</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__ipow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise self to the power other, in place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_data</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">other_mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__ipow__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                         <span class="n">other_data</span><span class="p">))</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">invalid</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">|=</span> <span class="n">invalid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">invalid</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">invalid</span><span class="p">)</span>
        <span class="n">new_mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">other_mask</span><span class="p">,</span> <span class="n">invalid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to float.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only length-1 arrays can be converted &quot;</span>
                            <span class="s2">&quot;to Python scalars&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Warning: converting a masked element to nan.&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to int.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only length-1 arrays can be converted &quot;</span>
                            <span class="s2">&quot;to Python scalars&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="s1">&#39;Cannot convert masked element to a Python int.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__long__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to long.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only length-1 arrays can be converted &quot;</span>
                            <span class="s2">&quot;to Python scalars&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="s1">&#39;Cannot convert masked element to a Python long.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>


    <span class="k">def</span> <span class="nf">get_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the imaginary part of the masked array.</span>

<span class="sd">        The returned array is a view on the imaginary part of the `MaskedArray`</span>
<span class="sd">        whose `get_imag` method is called.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : MaskedArray</span>
<span class="sd">            The imaginary part of the masked array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_real, real, imag</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])</span>
<span class="sd">        &gt;&gt;&gt; x.get_imag()</span>
<span class="sd">        masked_array(data = [1.0 -- 1.6],</span>
<span class="sd">                     mask = [False  True False],</span>
<span class="sd">               fill_value = 1e+20)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">imag</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">get_imag</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Imaginary part.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the real part of the masked array.</span>

<span class="sd">        The returned array is a view on the real part of the `MaskedArray`</span>
<span class="sd">        whose `get_real` method is called.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : MaskedArray</span>
<span class="sd">            The real part of the masked array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_imag, real, imag</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])</span>
<span class="sd">        &gt;&gt;&gt; x.get_real()</span>
<span class="sd">        masked_array(data = [1.0 -- 3.45],</span>
<span class="sd">                     mask = [False  True False],</span>
<span class="sd">               fill_value = 1e+20)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="n">real</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">get_real</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Real part&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the non-masked elements of the array along the given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : None or int or tuple of ints, optional</span>
<span class="sd">            Axis or axes along which the count is performed.</span>
<span class="sd">            The default (`axis` = `None`) performs the count over all</span>
<span class="sd">            the dimensions of the input array. `axis` may be negative, in</span>
<span class="sd">            which case it counts from the last to the first axis.</span>

<span class="sd">            .. versionadded:: 1.10.0</span>

<span class="sd">            If this is a tuple of ints, the count is performed on multiple</span>
<span class="sd">            axes, instead of a single axis or all the axes as before.</span>
<span class="sd">        keepdims : bool, optional</span>
<span class="sd">            If this is set to True, the axes which are reduced are left</span>
<span class="sd">            in the result as dimensions with size one. With this option,</span>
<span class="sd">            the result will broadcast correctly against the array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : ndarray or scalar</span>
<span class="sd">            An array with the same shape as the input array, with the specified</span>
<span class="sd">            axis removed. If the array is a 0-d array, or if `axis` is None, a</span>
<span class="sd">            scalar is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        count_masked : Count masked elements in array or along a given axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">        &gt;&gt;&gt; a = ma.arange(6).reshape((2, 3))</span>
<span class="sd">        &gt;&gt;&gt; a[1, :] = ma.masked</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        masked_array(data =</span>
<span class="sd">         [[0 1 2]</span>
<span class="sd">         [-- -- --]],</span>
<span class="sd">                     mask =</span>
<span class="sd">         [[False False False]</span>
<span class="sd">         [ True  True  True]],</span>
<span class="sd">               fill_value = 999999)</span>
<span class="sd">        &gt;&gt;&gt; a.count()</span>
<span class="sd">        3</span>

<span class="sd">        When the `axis` keyword is specified an array of appropriate size is</span>
<span class="sd">        returned.</span>

<span class="sd">        &gt;&gt;&gt; a.count(axis=0)</span>
<span class="sd">        array([1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; a.count(axis=1)</span>
<span class="sd">        array([3, 0])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="c1"># special case for matrices (we assume no other subclasses modify</span>
        <span class="c1"># their dimensions)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="c1"># compare to _count_reduce_items in _methods.py</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="p">():</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">np</span><span class="o">.</span><span class="n">AxisError</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;keepdims&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

            <span class="n">axes</span> <span class="o">=</span> <span class="n">normalize_axis_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="n">items</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">items</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;keepdims&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">out_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                    <span class="n">out_dims</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
            <span class="c1"># make sure to return a 0-d array if axis is supplied</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">out_dims</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>

        <span class="c1"># take care of the masked singleton</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 1D version of self, as a view.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span>
<span class="sd">            The elements of `a` are read using this index order. &#39;C&#39; means to</span>
<span class="sd">            index the elements in C-like order, with the last axis index</span>
<span class="sd">            changing fastest, back to the first axis index changing slowest.</span>
<span class="sd">            &#39;F&#39; means to index the elements in Fortran-like index order, with</span>
<span class="sd">            the first index changing fastest, and the last index changing</span>
<span class="sd">            slowest. Note that the &#39;C&#39; and &#39;F&#39; options take no account of the</span>
<span class="sd">            memory layout of the underlying array, and only refer to the order</span>
<span class="sd">            of axis indexing.  &#39;A&#39; means to read the elements in Fortran-like</span>
<span class="sd">            index order if `m` is Fortran *contiguous* in memory, C-like order</span>
<span class="sd">            otherwise.  &#39;K&#39; means to read the elements in the order they occur</span>
<span class="sd">            in memory, except for reversing the data when strides are negative.</span>
<span class="sd">            By default, &#39;C&#39; index order is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MaskedArray</span>
<span class="sd">            Output view is of shape ``(self.size,)`` (or</span>
<span class="sd">            ``(np.ma.product(self.shape),)``).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[1 -- 3]</span>
<span class="sd">         [-- 5 --]</span>
<span class="sd">         [7 -- 9]]</span>
<span class="sd">        &gt;&gt;&gt; print(x.ravel())</span>
<span class="sd">        [1 -- 3 -- 5 -- 7 -- 9]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">r</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">nomask</span>
        <span class="k">return</span> <span class="n">r</span>


    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a new shape to the array without changing its data.</span>

<span class="sd">        Returns a masked array containing the same data, but with a new shape.</span>
<span class="sd">        The result is a view on the original array; if this is not possible, a</span>
<span class="sd">        ValueError is raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : int or tuple of ints</span>
<span class="sd">            The new shape should be compatible with the original shape. If an</span>
<span class="sd">            integer is supplied, then the result will be a 1-D array of that</span>
<span class="sd">            length.</span>
<span class="sd">        order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">            Determines whether the array data should be viewed as in C</span>
<span class="sd">            (row-major) or FORTRAN (column-major) order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reshaped_array : array</span>
<span class="sd">            A new view on the array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        reshape : Equivalent function in the masked array module.</span>
<span class="sd">        numpy.ndarray.reshape : Equivalent method on ndarray object.</span>
<span class="sd">        numpy.reshape : Equivalent function in the NumPy module.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The reshaping operation cannot guarantee that a copy will not be made,</span>
<span class="sd">        to modify the shape in place, use ``a.shape = s``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[-- 2]</span>
<span class="sd">         [3 --]]</span>
<span class="sd">        &gt;&gt;&gt; x = x.reshape((4,1))</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[--]</span>
<span class="sd">         [2]</span>
<span class="sd">         [3]</span>
<span class="sd">         [--]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">refcheck</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. warning::</span>

<span class="sd">            This method does nothing, except raise a ValueError exception. A</span>
<span class="sd">            masked array does not own its data and therefore cannot safely be</span>
<span class="sd">            resized in place. Use the `numpy.ma.resize` function instead.</span>

<span class="sd">        This method is difficult to implement safely and may be deprecated in</span>
<span class="sd">        future releases of NumPy.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note : the &#39;order&#39; keyword looks broken, let&#39;s just drop it</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;A masked array does not own its data &quot;</span>\
                 <span class="s2">&quot;and therefore cannot be resized.</span><span class="se">\n</span><span class="s2">&quot;</span> \
                 <span class="s2">&quot;Use the numpy.ma.resize function instead.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set storage-indexed locations to corresponding values.</span>

<span class="sd">        Sets self._data.flat[n] = values[n] for each n in indices.</span>
<span class="sd">        If `values` is shorter than `indices` then it will repeat.</span>
<span class="sd">        If `values` has some masked values, the initial mask is updated</span>
<span class="sd">        in consequence, else the corresponding values are unmasked.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : 1-D array_like</span>
<span class="sd">            Target indices, interpreted as integers.</span>
<span class="sd">        values : array_like</span>
<span class="sd">            Values to place in self._data copy at target indices.</span>
<span class="sd">        mode : {&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;}, optional</span>
<span class="sd">            Specifies how out-of-bounds indices will behave.</span>
<span class="sd">            &#39;raise&#39; : raise an error.</span>
<span class="sd">            &#39;wrap&#39; : wrap around.</span>
<span class="sd">            &#39;clip&#39; : clip to the range.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        `values` can be a scalar or length 1 array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[1 -- 3]</span>
<span class="sd">         [-- 5 --]</span>
<span class="sd">         [7 -- 9]]</span>
<span class="sd">        &gt;&gt;&gt; x.put([0,4,8],[10,20,30])</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[10 -- 3]</span>
<span class="sd">         [-- 20 --]</span>
<span class="sd">         [7 -- 30]]</span>

<span class="sd">        &gt;&gt;&gt; x.put(4,999)</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[10 -- 3]</span>
<span class="sd">         [-- 999 --]</span>
<span class="sd">         [7 -- 30]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Hard mask: Get rid of the values/indices that fall on masked data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">narray</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">narray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="c1"># short circuit if neither self nor values are masked</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">getmask</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">getmask</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the addresses of the data and mask areas.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([1, 2, 3], mask=[0, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; x.ids()</span>
<span class="sd">        (166670640, 166659832)</span>

<span class="sd">        If the array has no mask, the address of `nomask` is returned. This address</span>
<span class="sd">        is typically not close to the data in memory:</span>

<span class="sd">        &gt;&gt;&gt; x = np.ma.array([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.ids()</span>
<span class="sd">        (166691080, 3083169284L)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">nomask</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iscontiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean indicating whether the data is contiguous.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.iscontiguous()</span>
<span class="sd">        True</span>

<span class="sd">        `iscontiguous` returns one of the flags of the masked array:</span>

<span class="sd">        &gt;&gt;&gt; x.flags</span>
<span class="sd">          C_CONTIGUOUS : True</span>
<span class="sd">          F_CONTIGUOUS : True</span>
<span class="sd">          OWNDATA : False</span>
<span class="sd">          WRITEABLE : True</span>
<span class="sd">          ALIGNED : True</span>
<span class="sd">          WRITEBACKIFCOPY : False</span>
<span class="sd">          UPDATEIFCOPY : False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;CONTIGUOUS&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if all elements evaluate to True.</span>

<span class="sd">        The output array is masked where all the values along the given axis</span>
<span class="sd">        are masked: if the output would have been a scalar and that all the</span>
<span class="sd">        values are masked, then the output is `masked`.</span>

<span class="sd">        Refer to `numpy.all` for full documentation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.all : corresponding function for ndarrays</span>
<span class="sd">        numpy.all : equivalent function</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; np.ma.array([1,2,3]).all()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; a = np.ma.array([1,2,3], mask=True)</span>
<span class="sd">        &gt;&gt;&gt; (a.all() is np.ma.masked)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">_check_mask_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mask</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">mask</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if any of the elements of `a` evaluate to True.</span>

<span class="sd">        Masked values are considered as False during computation.</span>

<span class="sd">        Refer to `numpy.any` for full documentation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.any : corresponding function for ndarrays</span>
<span class="sd">        numpy.any : equivalent function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">_check_mask_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mask</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">mask</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices of unmasked elements that are not zero.</span>

<span class="sd">        Returns a tuple of arrays, one for each dimension, containing the</span>
<span class="sd">        indices of the non-zero elements in that dimension. The corresponding</span>
<span class="sd">        non-zero values can be obtained with::</span>

<span class="sd">            a[a.nonzero()]</span>

<span class="sd">        To group the indices by element, rather than dimension, use</span>
<span class="sd">        instead::</span>

<span class="sd">            np.transpose(a.nonzero())</span>

<span class="sd">        The result of this is always a 2d array, with a row for each non-zero</span>
<span class="sd">        element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple_of_arrays : tuple</span>
<span class="sd">            Indices of elements that are non-zero.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.nonzero :</span>
<span class="sd">            Function operating on ndarrays.</span>
<span class="sd">        flatnonzero :</span>
<span class="sd">            Return indices that are non-zero in the flattened version of the input</span>
<span class="sd">            array.</span>
<span class="sd">        ndarray.nonzero :</span>
<span class="sd">            Equivalent ndarray method.</span>
<span class="sd">        count_nonzero :</span>
<span class="sd">            Counts the number of non-zero elements in the input array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">        &gt;&gt;&gt; x = ma.array(np.eye(3))</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        masked_array(data =</span>
<span class="sd">         [[ 1.  0.  0.]</span>
<span class="sd">         [ 0.  1.  0.]</span>
<span class="sd">         [ 0.  0.  1.]],</span>
<span class="sd">              mask =</span>
<span class="sd">         False,</span>
<span class="sd">              fill_value=1e+20)</span>
<span class="sd">        &gt;&gt;&gt; x.nonzero()</span>
<span class="sd">        (array([0, 1, 2]), array([0, 1, 2]))</span>

<span class="sd">        Masked elements are ignored.</span>

<span class="sd">        &gt;&gt;&gt; x[1, 1] = ma.masked</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        masked_array(data =</span>
<span class="sd">         [[1.0 0.0 0.0]</span>
<span class="sd">         [0.0 -- 0.0]</span>
<span class="sd">         [0.0 0.0 1.0]],</span>
<span class="sd">              mask =</span>
<span class="sd">         [[False False False]</span>
<span class="sd">         [False  True False]</span>
<span class="sd">         [False False False]],</span>
<span class="sd">              fill_value=1e+20)</span>
<span class="sd">        &gt;&gt;&gt; x.nonzero()</span>
<span class="sd">        (array([0, 2]), array([0, 2]))</span>

<span class="sd">        Indices can also be grouped by element.</span>

<span class="sd">        &gt;&gt;&gt; np.transpose(x.nonzero())</span>
<span class="sd">        array([[0, 0],</span>
<span class="sd">               [2, 2]])</span>

<span class="sd">        A common use for ``nonzero`` is to find the indices of an array, where</span>
<span class="sd">        a condition is True.  Given an array `a`, the condition `a` &gt; 3 is a</span>
<span class="sd">        boolean array and since False is interpreted as 0, ma.nonzero(a &gt; 3)</span>
<span class="sd">        yields the indices of the `a` where the condition is true.</span>

<span class="sd">        &gt;&gt;&gt; a = ma.array([[1,2,3],[4,5,6],[7,8,9]])</span>
<span class="sd">        &gt;&gt;&gt; a &gt; 3</span>
<span class="sd">        masked_array(data =</span>
<span class="sd">         [[False False False]</span>
<span class="sd">         [ True  True  True]</span>
<span class="sd">         [ True  True  True]],</span>
<span class="sd">              mask =</span>
<span class="sd">         False,</span>
<span class="sd">              fill_value=999999)</span>
<span class="sd">        &gt;&gt;&gt; ma.nonzero(a &gt; 3)</span>
<span class="sd">        (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>

<span class="sd">        The ``nonzero`` method of the condition array can also be called.</span>

<span class="sd">        &gt;&gt;&gt; (a &gt; 3).nonzero()</span>
<span class="sd">        (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">narray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (this docstring should be overwritten)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#!!!: implement out + test!</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span>
                                                    <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">D</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="n">trace</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a.dot(b, out=None)</span>

<span class="sd">        Masked dot product of two arrays. Note that `out` and `strict` are</span>
<span class="sd">        located in different positions than in `ma.dot`. In order to</span>
<span class="sd">        maintain compatibility with the functional version, it is</span>
<span class="sd">        recommended that the optional arguments be treated as keyword only.</span>
<span class="sd">        At some point that may be mandatory.</span>

<span class="sd">        .. versionadded:: 1.10.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        b : masked_array_like</span>
<span class="sd">            Inputs array.</span>
<span class="sd">        out : masked_array, optional</span>
<span class="sd">            Output argument. This must have the exact kind that would be</span>
<span class="sd">            returned if it was not used. In particular, it must have the</span>
<span class="sd">            right type, must be C-contiguous, and its dtype must be the</span>
<span class="sd">            dtype that would be returned for `ma.dot(a,b)`. This is a</span>
<span class="sd">            performance feature. Therefore, if these conditions are not</span>
<span class="sd">            met, an exception is raised, instead of attempting to be</span>
<span class="sd">            flexible.</span>
<span class="sd">        strict : bool, optional</span>
<span class="sd">            Whether masked data are propagated (True) or set to 0 (False)</span>
<span class="sd">            for the computation. Default is False.  Propagating the mask</span>
<span class="sd">            means that if a masked value appears in a row or column, the</span>
<span class="sd">            whole row or column is considered masked.</span>

<span class="sd">            .. versionadded:: 1.10.2</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ma.dot : equivalent function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sum of the array elements over the given axis.</span>

<span class="sd">        Masked elements are set to 0 internally.</span>

<span class="sd">        Refer to `numpy.sum` for full documentation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.sum : corresponding function for ndarrays</span>
<span class="sd">        numpy.sum : equivalent function</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[1 -- 3]</span>
<span class="sd">         [-- 5 --]</span>
<span class="sd">         [7 -- 9]]</span>
<span class="sd">        &gt;&gt;&gt; print(x.sum())</span>
<span class="sd">        25</span>
<span class="sd">        &gt;&gt;&gt; print(x.sum(axis=1))</span>
<span class="sd">        [4 5 16]</span>
<span class="sd">        &gt;&gt;&gt; print(x.sum(axis=0))</span>
<span class="sd">        [8 5 12]</span>
<span class="sd">        &gt;&gt;&gt; print(type(x.sum(axis=0, dtype=np.int64)[0]))</span>
<span class="sd">        &lt;type &#39;numpy.int64&#39;&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">newmask</span> <span class="o">=</span> <span class="n">_check_mask_axis</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># No explicit output</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">rndim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rndim</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">newmask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">newmask</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># Explicit output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">outmask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outmask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">outmask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">newmask</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cumulative sum of the array elements over the given axis.</span>

<span class="sd">        Masked values are set to 0 internally during the computation.</span>
<span class="sd">        However, their position is saved, and the result will be masked at</span>
<span class="sd">        the same locations.</span>

<span class="sd">        Refer to `numpy.cumsum` for full documentation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The mask is lost if `out` is not a valid :class:`MaskedArray` !</span>

<span class="sd">        Arithmetic is modular when using integer types, and no error is</span>
<span class="sd">        raised on overflow.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.cumsum : corresponding function for ndarrays</span>
<span class="sd">        numpy.cumsum : equivalent function</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])</span>
<span class="sd">        &gt;&gt;&gt; print(marr.cumsum())</span>
<span class="sd">        [0 1 3 -- -- -- 9 16 24 33]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the product of the array elements over the given axis.</span>

<span class="sd">        Masked elements are set to 1 internally for computation.</span>

<span class="sd">        Refer to `numpy.prod` for full documentation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Arithmetic is modular when using integer types, and no error is raised</span>
<span class="sd">        on overflow.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.prod : corresponding function for ndarrays</span>
<span class="sd">        numpy.prod : equivalent function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">newmask</span> <span class="o">=</span> <span class="n">_check_mask_axis</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># No explicit output</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">rndim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rndim</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">newmask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">newmask</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># Explicit output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">outmask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outmask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">outmask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">newmask</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="n">product</span> <span class="o">=</span> <span class="n">prod</span>

    <span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cumulative product of the array elements over the given axis.</span>

<span class="sd">        Masked values are set to 1 internally during the computation.</span>
<span class="sd">        However, their position is saved, and the result will be masked at</span>
<span class="sd">        the same locations.</span>

<span class="sd">        Refer to `numpy.cumprod` for full documentation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The mask is lost if `out` is not a valid MaskedArray !</span>

<span class="sd">        Arithmetic is modular when using integer types, and no error is</span>
<span class="sd">        raised on overflow.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.cumprod : corresponding function for ndarrays</span>
<span class="sd">        numpy.cumprod : equivalent function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the average of the array elements along given axis.</span>

<span class="sd">        Masked entries are ignored, and result elements which are not</span>
<span class="sd">        finite will be masked.</span>

<span class="sd">        Refer to `numpy.mean` for full documentation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.mean : corresponding function for ndarrays</span>
<span class="sd">        numpy.mean : Equivalent function</span>
<span class="sd">        numpy.ma.average: Weighted average.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = np.ma.array([1,2,3], mask=[False, False, True])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        masked_array(data = [1 2 --],</span>
<span class="sd">                     mask = [False False  True],</span>
<span class="sd">               fill_value = 999999)</span>
<span class="sd">        &gt;&gt;&gt; a.mean()</span>
<span class="sd">        1.5</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                                   <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dsum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cnt</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">dsum</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">cnt</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">outmask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
                    <span class="n">outmask</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">outmask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">anom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the anomalies (deviations from the arithmetic mean)</span>
<span class="sd">        along the given axis.</span>

<span class="sd">        Returns an array of anomalies, with the same shape as the input and</span>
<span class="sd">        where the arithmetic mean is computed along the given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis over which the anomalies are taken.</span>
<span class="sd">            The default is to use the mean of the flattened array as reference.</span>
<span class="sd">        dtype : dtype, optional</span>
<span class="sd">            Type to use in computing the variance. For arrays of integer type</span>
<span class="sd">             the default is float32; for arrays of float types it is the same as</span>
<span class="sd">             the array type.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mean : Compute the mean of the array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = np.ma.array([1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; a.anom()</span>
<span class="sd">        masked_array(data = [-1.  0.  1.],</span>
<span class="sd">                     mask = False,</span>
<span class="sd">               fill_value = 1e+20)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">axis</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the variance of the array elements along given axis.</span>

<span class="sd">        Masked entries are ignored, and result elements which are not</span>
<span class="sd">        finite will be masked.</span>

<span class="sd">        Refer to `numpy.var` for full documentation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.var : corresponding function for ndarrays</span>
<span class="sd">        numpy.var : Equivalent function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

        <span class="c1"># Easy case: nomask, business as usual</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                                               <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[()]</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">nomask</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">out</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="c1"># Some data are masked, yay!</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-</span> <span class="n">ddof</span>
        <span class="n">danom</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">danom</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">danom</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">danom</span> <span class="o">*=</span> <span class="n">danom</span>
        <span class="n">dvar</span> <span class="o">=</span> <span class="n">divide</span><span class="p">(</span><span class="n">danom</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">cnt</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="c1"># Apply the mask if it&#39;s not a scalar</span>
        <span class="k">if</span> <span class="n">dvar</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">dvar</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">dvar</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">getmask</span><span class="p">(</span><span class="n">dvar</span><span class="p">):</span>
            <span class="c1"># Make sure that masked is returned when the scalar is masked.</span>
            <span class="n">dvar</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;biu&#39;</span><span class="p">:</span>
                    <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Masked data information would be lost in one or &quot;</span>\
                             <span class="s2">&quot;more location.&quot;</span>
                    <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">return</span> <span class="n">out</span>
        <span class="c1"># In case with have an explicit output</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Set the data</span>
            <span class="n">out</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">dvar</span>
            <span class="c1"># Set the mask if needed</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">dvar</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">dvar</span>
    <span class="n">var</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the standard deviation of the array elements along given axis.</span>

<span class="sd">        Masked entries are ignored.</span>

<span class="sd">        Refer to `numpy.std` for full documentation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.std : corresponding function for ndarrays</span>
<span class="sd">        numpy.std : Equivalent function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

        <span class="n">dvar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dvar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">out</span>
            <span class="n">dvar</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dvar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dvar</span>

    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return each element rounded to the given number of decimals.</span>

<span class="sd">        Refer to `numpy.around` for full documentation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.around : corresponding function for ndarrays</span>
<span class="sd">        numpy.around : equivalent function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">:</span>
            <span class="c1"># Return masked when the scalar is masked</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">masked</span>
        <span class="c1"># No explicit output: we&#39;re done</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">endwith</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an ndarray of indices that sort the array along the</span>
<span class="sd">        specified axis.  Masked values are filled beforehand to</span>
<span class="sd">        `fill_value`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to sort. If None, the default, the flattened array</span>
<span class="sd">            is used.</span>

<span class="sd">            ..  versionchanged:: 1.13.0</span>
<span class="sd">                Previously, the default was documented to be -1, but that was</span>
<span class="sd">                in error. At some future date, the default will change to -1, as</span>
<span class="sd">                originally intended.</span>
<span class="sd">                Until then, the axis should be given explicitly when</span>
<span class="sd">                ``arr.ndim &gt; 1``, to avoid a FutureWarning.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;, &#39;stable&#39;}, optional</span>
<span class="sd">            Sorting algorithm.</span>
<span class="sd">        order : list, optional</span>
<span class="sd">            When `a` is an array with fields defined, this argument specifies</span>
<span class="sd">            which fields to compare first, second, etc.  Not all fields need be</span>
<span class="sd">            specified.</span>
<span class="sd">        endwith : {True, False}, optional</span>
<span class="sd">            Whether missing values (if any) should be treated as the largest values</span>
<span class="sd">            (True) or the smallest values (False)</span>
<span class="sd">            When the array contains unmasked values at the same extremes of the</span>
<span class="sd">            datatype, the ordering of these values and the masked values is</span>
<span class="sd">            undefined.</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used internally for the masked values.</span>
<span class="sd">            If ``fill_value`` is not None, it supersedes ``endwith``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index_array : ndarray, int</span>
<span class="sd">            Array of indices that sort `a` along the specified axis.</span>
<span class="sd">            In other words, ``a[index_array]`` yields a sorted `a`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        MaskedArray.sort : Describes sorting algorithms used.</span>
<span class="sd">        lexsort : Indirect stable sort with multiple keys.</span>
<span class="sd">        ndarray.sort : Inplace sort.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See `sort` for notes on the different sorting algorithms.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = np.ma.array([3,2,1], mask=[False, False, True])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        masked_array(data = [3 2 --],</span>
<span class="sd">                     mask = [False False  True],</span>
<span class="sd">               fill_value = 999999)</span>
<span class="sd">        &gt;&gt;&gt; a.argsort()</span>
<span class="sd">        array([1, 0, 2])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 2017-04-11, Numpy 1.13.0, gh-8701: warn on axis default</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">_deprecate_argsort_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">endwith</span><span class="p">:</span>
                <span class="c1"># nan &gt; inf</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="n">minimum_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">maximum_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">filled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filled</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return array of indices to the minimum values along the given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, integer}</span>
<span class="sd">            If None, the index is into the flattened array, otherwise along</span>
<span class="sd">            the specified axis</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used to fill in the masked values.  If None, the output of</span>
<span class="sd">            minimum_fill_value(self._data) is used instead.</span>
<span class="sd">        out : {None, array}, optional</span>
<span class="sd">            Array into which the result can be placed. Its type is preserved</span>
<span class="sd">            and it must be of the right shape to hold the output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray or scalar</span>
<span class="sd">            If multi-dimension input, returns a new ndarray of indices to the</span>
<span class="sd">            minimum values along the given axis.  Otherwise, returns a scalar</span>
<span class="sd">            of index to the minimum values along the given axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array(arange(4), mask=[1,1,0,0])</span>
<span class="sd">        &gt;&gt;&gt; x.shape = (2,2)</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[-- --]</span>
<span class="sd">         [2 3]]</span>
<span class="sd">        &gt;&gt;&gt; print(x.argmin(axis=0, fill_value=-1))</span>
<span class="sd">        [0 0]</span>
<span class="sd">        &gt;&gt;&gt; print(x.argmin(axis=0, fill_value=9))</span>
<span class="sd">        [1 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">minimum_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns array of indices of the maximum values along the given axis.</span>
<span class="sd">        Masked values are treated as if they had the value fill_value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, integer}</span>
<span class="sd">            If None, the index is into the flattened array, otherwise along</span>
<span class="sd">            the specified axis</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used to fill in the masked values.  If None, the output of</span>
<span class="sd">            maximum_fill_value(self._data) is used instead.</span>
<span class="sd">        out : {None, array}, optional</span>
<span class="sd">            Array into which the result can be placed. Its type is preserved</span>
<span class="sd">            and it must be of the right shape to hold the output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index_array : {integer_array}</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = np.arange(6).reshape(2,3)</span>
<span class="sd">        &gt;&gt;&gt; a.argmax()</span>
<span class="sd">        5</span>
<span class="sd">        &gt;&gt;&gt; a.argmax(0)</span>
<span class="sd">        array([1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; a.argmax(1)</span>
<span class="sd">        array([2, 2])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">maximum_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">endwith</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the array, in-place</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : array_like</span>
<span class="sd">            Array to be sorted.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to sort. If None, the array is flattened before</span>
<span class="sd">            sorting. The default is -1, which sorts along the last axis.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;, &#39;stable&#39;}, optional</span>
<span class="sd">            Sorting algorithm. Default is &#39;quicksort&#39;.</span>
<span class="sd">        order : list, optional</span>
<span class="sd">            When `a` is a structured array, this argument specifies which fields</span>
<span class="sd">            to compare first, second, and so on.  This list does not need to</span>
<span class="sd">            include all of the fields.</span>
<span class="sd">        endwith : {True, False}, optional</span>
<span class="sd">            Whether missing values (if any) should be treated as the largest values</span>
<span class="sd">            (True) or the smallest values (False)</span>
<span class="sd">            When the array contains unmasked values at the same extremes of the</span>
<span class="sd">            datatype, the ordering of these values and the masked values is</span>
<span class="sd">            undefined.</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used internally for the masked values.</span>
<span class="sd">            If ``fill_value`` is not None, it supersedes ``endwith``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted_array : ndarray</span>
<span class="sd">            Array of the same type and shape as `a`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.sort : Method to sort an array in-place.</span>
<span class="sd">        argsort : Indirect sort.</span>
<span class="sd">        lexsort : Indirect stable sort on multiple keys.</span>
<span class="sd">        searchsorted : Find elements in a sorted array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See ``sort`` for notes on the different sorting algorithms.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; # Default</span>
<span class="sd">        &gt;&gt;&gt; a.sort()</span>
<span class="sd">        &gt;&gt;&gt; print(a)</span>
<span class="sd">        [1 3 5 -- --]</span>

<span class="sd">        &gt;&gt;&gt; a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; # Put missing values in the front</span>
<span class="sd">        &gt;&gt;&gt; a.sort(endwith=False)</span>
<span class="sd">        &gt;&gt;&gt; print(a)</span>
<span class="sd">        [-- -- 1 3 5]</span>

<span class="sd">        &gt;&gt;&gt; a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; # fill_value takes over endwith</span>
<span class="sd">        &gt;&gt;&gt; a.sort(endwith=False, fill_value=3)</span>
<span class="sd">        &gt;&gt;&gt; print(a)</span>
<span class="sd">        [1 -- -- 3 5]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">ndarray</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">sidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">endwith</span><span class="o">=</span><span class="n">endwith</span><span class="p">)</span>

        <span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sidx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum along a given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, int}, optional</span>
<span class="sd">            Axis along which to operate.  By default, ``axis`` is None and the</span>
<span class="sd">            flattened input is used.</span>
<span class="sd">        out : array_like, optional</span>
<span class="sd">            Alternative output array in which to place the result.  Must be of</span>
<span class="sd">            the same shape and buffer length as the expected output.</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used to fill in the masked values.</span>
<span class="sd">            If None, use the output of `minimum_fill_value`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        amin : array_like</span>
<span class="sd">            New array holding the result.</span>
<span class="sd">            If ``out`` was specified, ``out`` is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        minimum_fill_value</span>
<span class="sd">            Returns the minimum filling value for a given datatype.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">newmask</span> <span class="o">=</span> <span class="n">_check_mask_axis</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">minimum_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># No explicit output</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="c1"># Set the mask</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">newmask</span><span class="p">)</span>
                <span class="c1"># Get rid of Infs</span>
                <span class="k">if</span> <span class="n">newmask</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">newmask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">newmask</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># Explicit output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">outmask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outmask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">outmask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">newmask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;biu&#39;</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Masked data information would be lost in one or more&quot;</span>\
                         <span class="s2">&quot; location.&quot;</span>
                <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">newmask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="c1"># unique to masked arrays</span>
    <span class="k">def</span> <span class="nf">mini</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the array minimum along the specified axis.</span>

<span class="sd">        .. deprecated:: 1.13.0</span>
<span class="sd">           This function is identical to both:</span>

<span class="sd">            * ``self.min(keepdims=True, axis=axis).squeeze(axis=axis)``</span>
<span class="sd">            * ``np.ma.minimum.reduce(self, axis=axis)``</span>

<span class="sd">           Typically though, ``self.min(axis=axis)`` is sufficient.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            The axis along which to find the minima. Default is None, in which case</span>
<span class="sd">            the minimum value in the whole array is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        min : scalar or MaskedArray</span>
<span class="sd">            If `axis` is None, the result is a scalar. Otherwise, if `axis` is</span>
<span class="sd">            given and the array is at least 2-D, the result is a masked array with</span>
<span class="sd">            dimension one smaller than the array on which `mini` is called.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[0 --]</span>
<span class="sd">         [2 3]</span>
<span class="sd">         [4 --]]</span>
<span class="sd">        &gt;&gt;&gt; x.mini()</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; x.mini(axis=0)</span>
<span class="sd">        masked_array(data = [0 3],</span>
<span class="sd">                     mask = [False False],</span>
<span class="sd">               fill_value = 999999)</span>
<span class="sd">        &gt;&gt;&gt; print(x.mini(axis=1))</span>
<span class="sd">        [0 2 4]</span>

<span class="sd">        There is a small difference between `mini` and `min`:</span>

<span class="sd">        &gt;&gt;&gt; x[:,1].mini(axis=0)</span>
<span class="sd">        masked_array(data = --,</span>
<span class="sd">                     mask = True,</span>
<span class="sd">               fill_value = 999999)</span>
<span class="sd">        &gt;&gt;&gt; x[:,1].min(axis=0)</span>
<span class="sd">        masked</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 2016-04-13, 1.13.0, gh-8764</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;`mini` is deprecated; use the `min` method or &quot;</span>
            <span class="s2">&quot;`np.ma.minimum.reduce instead.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">minimum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the maximum along a given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, int}, optional</span>
<span class="sd">            Axis along which to operate.  By default, ``axis`` is None and the</span>
<span class="sd">            flattened input is used.</span>
<span class="sd">        out : array_like, optional</span>
<span class="sd">            Alternative output array in which to place the result.  Must</span>
<span class="sd">            be of the same shape and buffer length as the expected output.</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used to fill in the masked values.</span>
<span class="sd">            If None, use the output of maximum_fill_value().</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        amax : array_like</span>
<span class="sd">            New array holding the result.</span>
<span class="sd">            If ``out`` was specified, ``out`` is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        maximum_fill_value</span>
<span class="sd">            Returns the maximum filling value for a given datatype.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">newmask</span> <span class="o">=</span> <span class="n">_check_mask_axis</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">maximum_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># No explicit output</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="c1"># Set the mask</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">newmask</span><span class="p">)</span>
                <span class="c1"># Get rid of Infs</span>
                <span class="k">if</span> <span class="n">newmask</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">newmask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">newmask</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># Explicit output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">outmask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outmask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">outmask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">newmask</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;biu&#39;</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Masked data information would be lost in one or more&quot;</span>\
                         <span class="s2">&quot; location.&quot;</span>
                <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">newmask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">ptp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return (maximum - minimum) along the given dimension</span>
<span class="sd">        (i.e. peak-to-peak value).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, int}, optional</span>
<span class="sd">            Axis along which to find the peaks.  If None (default) the</span>
<span class="sd">            flattened array is used.</span>
<span class="sd">        out : {None, array_like}, optional</span>
<span class="sd">            Alternative output array in which to place the result. It must</span>
<span class="sd">            have the same shape and buffer length as the expected output</span>
<span class="sd">            but the type will be cast if necessary.</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used to fill in the masked values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ptp : ndarray.</span>
<span class="sd">            A new array holding the result, unless ``out`` was</span>
<span class="sd">            specified, in which case a reference to ``out`` is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                              <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                               <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">out</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                            <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="n">min_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                             <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">min_value</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;partition&#39; will ignore the &#39;mask&#39; &quot;</span>
                      <span class="s2">&quot;of the </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                      <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argpartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;argpartition&#39; will ignore the &#39;mask&#39; &quot;</span>
                      <span class="s2">&quot;of the </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                      <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="n">_mask</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Make sure the indices are not masked</span>
        <span class="n">maskindices</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maskindices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Get the data, promoting scalars to 0d arrays with [...] so that</span>
        <span class="c1"># .view works correctly</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)[</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="c1"># Get the mask</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">maskindices</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">_mask</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
                <span class="n">outmask</span> <span class="o">|=</span> <span class="n">maskindices</span>
            <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">outmask</span><span class="p">)</span>
        <span class="c1"># demote 0d arrays back to scalars, for consistency with ndarray.take</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[()]</span>

    <span class="c1"># Array methods</span>
    <span class="n">clip</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;clip&#39;</span><span class="p">,</span> <span class="n">onmask</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">)</span>
    <span class="n">diagonal</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;diagonal&#39;</span><span class="p">)</span>
    <span class="n">flatten</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;flatten&#39;</span><span class="p">)</span>
    <span class="n">repeat</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;repeat&#39;</span><span class="p">)</span>
    <span class="n">squeeze</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;squeeze&#39;</span><span class="p">)</span>
    <span class="n">swapaxes</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;swapaxes&#39;</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
    <span class="n">transpose</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;transpose&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the data portion of the masked array as a hierarchical Python list.</span>

<span class="sd">        Data items are converted to the nearest compatible Python type.</span>
<span class="sd">        Masked values are converted to `fill_value`. If `fill_value` is None,</span>
<span class="sd">        the corresponding entries in the output list will be ``None``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fill_value : scalar, optional</span>
<span class="sd">            The value to use for invalid entries. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : list</span>
<span class="sd">            The Python list representation of the masked array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; x.tolist()</span>
<span class="sd">        [[1, None, 3], [None, 5, None], [7, None, 9]]</span>
<span class="sd">        &gt;&gt;&gt; x.tolist(-999)</span>
<span class="sd">        [[1, -999, 3], [-999, 5, -999], [7, -999, 9]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="c1"># No mask ? Just return .data.tolist ?</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># Explicit fill_value: fill the array and get the list</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># Structured array.</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">if</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">astype</span><span class="p">([(</span><span class="n">_</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">names</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">_mask</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># Standard arrays.</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="c1"># Set temps to save time when dealing w/ marrays.</span>
        <span class="n">inishape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">_mask</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">result</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">inishape</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tostring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is a compatibility alias for tobytes. Despite its name it</span>
<span class="sd">        returns bytes not strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tobytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the array data as a string containing the raw bytes in the array.</span>

<span class="sd">        The array is filled with a fill value before the string conversion.</span>

<span class="sd">        .. versionadded:: 1.9.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fill_value : scalar, optional</span>
<span class="sd">            Value used to fill in the masked values. Default is None, in which</span>
<span class="sd">            case `MaskedArray.fill_value` is used.</span>
<span class="sd">        order : {&#39;C&#39;,&#39;F&#39;,&#39;A&#39;}, optional</span>
<span class="sd">            Order of the data item in the copy. Default is &#39;C&#39;.</span>

<span class="sd">            - &#39;C&#39;   -- C order (row major).</span>
<span class="sd">            - &#39;F&#39;   -- Fortran order (column major).</span>
<span class="sd">            - &#39;A&#39;   -- Any, current order of array.</span>
<span class="sd">            - None  -- Same as &#39;A&#39;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.tobytes</span>
<span class="sd">        tolist, tofile</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As for `ndarray.tobytes`, information about the shape, dtype, etc.,</span>
<span class="sd">        but also about `fill_value`, will be lost.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; x.tobytes()</span>
<span class="sd">        &#39;\\x01\\x00\\x00\\x00?B\\x0f\\x00?B\\x0f\\x00\\x04\\x00\\x00\\x00&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tofile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a masked array to a file in binary format.</span>

<span class="sd">        .. warning::</span>
<span class="sd">          This function is not implemented yet.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            When `tofile` is called.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;MaskedArray.tofile() not implemented yet.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">toflex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms a masked array into a flexible-type array.</span>

<span class="sd">        The flexible type array that is returned will have two fields:</span>

<span class="sd">        * the ``_data`` field stores the ``_data`` part of the array.</span>
<span class="sd">        * the ``_mask`` field stores the ``_mask`` part of the array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record : ndarray</span>
<span class="sd">            A new flexible-type `ndarray` with two fields: the first element</span>
<span class="sd">            containing a value, the second element containing the corresponding</span>
<span class="sd">            mask boolean. The returned record shape matches self.shape.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        A side-effect of transforming a masked array into a flexible `ndarray` is</span>
<span class="sd">        that meta information (``fill_value``, ...) will be lost.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [[1 -- 3]</span>
<span class="sd">         [-- 5 --]</span>
<span class="sd">         [7 -- 9]]</span>
<span class="sd">        &gt;&gt;&gt; print(x.toflex())</span>
<span class="sd">        [[(1, False) (2, True) (3, False)]</span>
<span class="sd">         [(4, True) (5, False) (6, True)]</span>
<span class="sd">         [(7, False) (8, True) (9, False)]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the basic dtype.</span>
        <span class="n">ddtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="c1"># Make sure we have a mask</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ddtype</span><span class="p">)</span>
        <span class="c1"># And get its dtype</span>
        <span class="n">mdtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">dtype</span>

        <span class="n">record</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;_data&#39;</span><span class="p">,</span> <span class="n">ddtype</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">mdtype</span><span class="p">)])</span>
        <span class="n">record</span><span class="p">[</span><span class="s1">&#39;_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">record</span><span class="p">[</span><span class="s1">&#39;_mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">return</span> <span class="n">record</span>
    <span class="n">torecords</span> <span class="o">=</span> <span class="n">toflex</span>

    <span class="c1"># Pickling</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the internal state of the masked array, for pickling</span>
<span class="sd">        purposes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cf</span> <span class="o">=</span> <span class="s1">&#39;CF&#39;</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span><span class="p">]</span>
        <span class="n">data_state</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data_state</span> <span class="o">+</span> <span class="p">(</span><span class="n">getmaskarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">cf</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restore the internal state of the masked array, for</span>
<span class="sd">        pickling purposes.  ``state`` is typically the output of the</span>
<span class="sd">        ``__getstate__`` output, and is a 5-tuple:</span>

<span class="sd">        - class name</span>
<span class="sd">        - a tuple giving the shape of the data</span>
<span class="sd">        - a typecode for the data</span>
<span class="sd">        - a binary string for the data</span>
<span class="sd">        - a binary string for the mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">shp</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">isf</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">msk</span><span class="p">,</span> <span class="n">flv</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">((</span><span class="n">shp</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">isf</span><span class="p">,</span> <span class="n">raw</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">((</span><span class="n">shp</span><span class="p">,</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="n">typ</span><span class="p">),</span> <span class="n">isf</span><span class="p">,</span> <span class="n">msk</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">flv</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a 3-tuple for pickling a MaskedArray.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_mareconstruct</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseclass</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="s1">&#39;b&#39;</span><span class="p">,),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
        <span class="n">copied</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">copied</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">copied</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">copied</span>


<span class="k">def</span> <span class="nf">_mareconstruct</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">baseclass</span><span class="p">,</span> <span class="n">baseshape</span><span class="p">,</span> <span class="n">basetype</span><span class="p">,):</span>
    <span class="sd">&quot;&quot;&quot;Internal function that builds a new MaskedArray from the</span>
<span class="sd">    information stored in a pickle.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_data</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">baseclass</span><span class="p">,</span> <span class="n">baseshape</span><span class="p">,</span> <span class="n">basetype</span><span class="p">)</span>
    <span class="n">_mask</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">baseshape</span><span class="p">,</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="n">basetype</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">subtype</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">basetype</span><span class="p">,)</span>


<span class="k">class</span> <span class="nc">mvoid</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fake a &#39;void&#39; object to use for masked array with structured dtypes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">nomask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">hardmask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_data</span><span class="o">.</span><span class="n">_hardmask</span> <span class="o">=</span> <span class="n">hardmask</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">):</span>
                <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Mask is already a 0D array</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="c1"># Transform the mask to a void</span>
                    <span class="n">mdtype</span> <span class="o">=</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)[()]</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_data</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">return</span> <span class="n">_data</span>

    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Make sure that the _data part is a np.void</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">mvoid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_data</span><span class="p">[()]</span>

    <span class="n">_data</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the index.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># Can happen when indx is a multi-dimensional field:</span>
            <span class="c1"># A = ma.masked_array(data=[([0,1],)], mask=[([True,</span>
            <span class="c1">#                     False],)], dtype=[(&quot;A&quot;, &quot;&gt;i2&quot;, (2,))])</span>
            <span class="c1"># x = A[0]; y = x[&quot;A&quot;]; then y.mask[&quot;A&quot;].size==2</span>
            <span class="c1"># and we can not say masked/unmasked.</span>
            <span class="c1"># The result is no longer mvoid!</span>
            <span class="c1"># See also issue #6724.</span>
            <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span>
                <span class="n">hard_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">m</span><span class="p">[</span><span class="n">indx</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">masked</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">|=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;_mask&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;_mask&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

        <span class="n">rdtype</span> <span class="o">=</span> <span class="n">_replace_dtype_fields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">)</span>
        <span class="n">data_arr</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">mvoid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">rdtype</span><span class="p">)</span>
        <span class="n">_recursive_printoption</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">masked_print_option</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Defines an iterator for mvoid&quot;</span>
        <span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="n">_mask</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_data</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="n">_mask</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">masked</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">filled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy with masked fields filled with a given value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fill_value : scalar, optional</span>
<span class="sd">            The value to use for invalid entries (None by default).</span>
<span class="sd">            If None, the `fill_value` attribute is used instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filled_void</span>
<span class="sd">            A `np.void` object</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        MaskedArray.filled</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)[()]</span>

    <span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms the mvoid object into a tuple.</span>

<span class="sd">    Masked fields are replaced by None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    returned_tuple</span>
<span class="sd">        Tuple of fields</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># .item() makes sure we return a standard Python object</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="c1">##############################################################################</span>
<span class="c1">#                                Shortcuts                                   #</span>
<span class="c1">##############################################################################</span>


<span class="k">def</span> <span class="nf">isMaskedArray</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test whether input is an instance of MaskedArray.</span>

<span class="sd">    This function returns True if `x` is an instance of MaskedArray</span>
<span class="sd">    and returns False otherwise.  Any object is accepted as input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : object</span>
<span class="sd">        Object to test.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : bool</span>
<span class="sd">        True if `x` is a MaskedArray.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    isMA : Alias to isMaskedArray.</span>
<span class="sd">    isarray : Alias to isMaskedArray.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.eye(3, 3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; m = ma.masked_values(a, 0)</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1.0 -- --]</span>
<span class="sd">     [-- 1.0 --]</span>
<span class="sd">     [-- -- 1.0]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False  True  True]</span>
<span class="sd">     [ True False  True]</span>
<span class="sd">     [ True  True False]],</span>
<span class="sd">          fill_value=0.0)</span>
<span class="sd">    &gt;&gt;&gt; ma.isMaskedArray(a)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ma.isMaskedArray(m)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ma.isMaskedArray([0, 1, 2])</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">)</span>


<span class="n">isarray</span> <span class="o">=</span> <span class="n">isMaskedArray</span>
<span class="n">isMA</span> <span class="o">=</span> <span class="n">isMaskedArray</span>  <span class="c1"># backward compatibility</span>


<span class="k">class</span> <span class="nc">MaskedConstant</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">):</span>
    <span class="c1"># the lone np.ma.masked instance</span>
    <span class="n">__singleton</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__has_singleton</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># second case ensures `cls.__singleton` is not just a view on the</span>
        <span class="c1"># superclass singleton</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__singleton</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__singleton</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">cls</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__has_singleton</span><span class="p">():</span>
            <span class="c1"># We define the masked singleton as a float for higher precedence.</span>
            <span class="c1"># Note that it can be tricky sometimes w/ type comparison</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># prevent any modifications</span>
            <span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">mask</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># don&#39;t fall back on MaskedArray.__new__(MaskedConstant), since</span>
            <span class="c1"># that might confuse it - this way, the construction is entirely</span>
            <span class="c1"># within our control</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">__singleton</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__singleton</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_singleton</span><span class="p">():</span>
            <span class="c1"># this handles the `.view` in __new__, which we want to copy across</span>
            <span class="c1"># properties normally</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedConstant</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__array_finalize__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">__singleton</span><span class="p">:</span>
            <span class="c1"># not clear how this can happen, play it safe</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># everywhere else, we want to downcast to MaskedArray, to prevent a</span>
            <span class="c1"># duplicate maskedconstant.</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">MaskedArray</span>
            <span class="n">MaskedArray</span><span class="o">.</span><span class="n">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_prepare__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span><span class="o">.</span><span class="n">__array_prepare__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">masked_print_option</span><span class="o">.</span><span class="n">_display</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">unicode</span><span class="p">(</span><span class="n">masked_print_option</span><span class="o">.</span><span class="n">_display</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">MaskedConstant</span><span class="o">.</span><span class="n">__singleton</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;masked&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># it&#39;s a subclass, or something is wrong, make it obvious</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override of MaskedArray&#39;s __reduce__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="p">())</span>

    <span class="c1"># inplace operations have no effect. We have to override them to avoid</span>
    <span class="c1"># trying to modify the readonly data and mask arrays</span>
    <span class="k">def</span> <span class="nf">__iop__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="fm">__iadd__</span> <span class="o">=</span> \
    <span class="fm">__isub__</span> <span class="o">=</span> \
    <span class="fm">__imul__</span> <span class="o">=</span> \
    <span class="fm">__ifloordiv__</span> <span class="o">=</span> \
    <span class="fm">__itruediv__</span> <span class="o">=</span> \
    <span class="fm">__ipow__</span> <span class="o">=</span> \
        <span class="n">__iop__</span>
    <span class="k">del</span> <span class="n">__iop__</span>  <span class="c1"># don&#39;t leave this around</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Copy is a no-op on the maskedconstant, as it is a scalar &quot;&quot;&quot;</span>
        <span class="c1"># maskedconstant is a scalar, so copy doesn&#39;t need to copy. There&#39;s</span>
        <span class="c1"># precedent for this with `np.bool_` scalars.</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
		
    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_singleton</span><span class="p">():</span>
            <span class="c1"># allow the singleton to be initialized</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedConstant</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">__singleton</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;attributes of </span><span class="si">{!r}</span><span class="s2"> are not writeable&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># duplicate instance - we can end up here from __array_finalize__,</span>
            <span class="c1"># where we set the __class__ attribute</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedConstant</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="n">masked</span> <span class="o">=</span> <span class="n">masked_singleton</span> <span class="o">=</span> <span class="n">MaskedConstant</span><span class="p">()</span>
<span class="n">masked_array</span> <span class="o">=</span> <span class="n">MaskedArray</span>


<span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">mask</span><span class="o">=</span><span class="n">nomask</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
          <span class="n">hard_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shortcut to MaskedArray.</span>

<span class="sd">    The options are in a different order for convenience and backwards</span>
<span class="sd">    compatibility.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                       <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">,</span> <span class="n">keep_mask</span><span class="o">=</span><span class="n">keep_mask</span><span class="p">,</span>
                       <span class="n">hard_mask</span><span class="o">=</span><span class="n">hard_mask</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                       <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="n">shrink</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
<span class="n">array</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">masked_array</span><span class="o">.</span><span class="vm">__doc__</span>


<span class="k">def</span> <span class="nf">is_masked</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine whether input has masked values.</span>

<span class="sd">    Accepts any object as input, but always returns False unless the</span>
<span class="sd">    input is a MaskedArray containing masked values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Array to check for masked values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : bool</span>
<span class="sd">        True if `x` is a MaskedArray with masked values, False otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; x = ma.masked_equal([0, 1, 0, 2, 3], 0)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    masked_array(data = [-- 1 -- 2 3],</span>
<span class="sd">          mask = [ True False  True False False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.is_masked(x)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x = ma.masked_equal([0, 1, 0, 2, 3], 42)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    masked_array(data = [0 1 0 2 3],</span>
<span class="sd">          mask = False,</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.is_masked(x)</span>
<span class="sd">    False</span>

<span class="sd">    Always returns False if `x` isn&#39;t a MaskedArray.</span>

<span class="sd">    &gt;&gt;&gt; x = [False, True, False]</span>
<span class="sd">    &gt;&gt;&gt; ma.is_masked(x)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; x = &#39;a string&#39;</span>
<span class="sd">    &gt;&gt;&gt; ma.is_masked(x)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="c1">##############################################################################</span>
<span class="c1">#                             Extrema functions                              #</span>
<span class="c1">##############################################################################</span>


<span class="k">class</span> <span class="nc">_extrema_operation</span><span class="p">(</span><span class="n">_MaskedUFunc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic class for maximum/minimum functions.</span>

<span class="sd">    .. note::</span>
<span class="sd">      This is the base class for `_maximum_operation` and</span>
<span class="sd">      `_minimum_operation`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">compare</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_extrema_operation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ufunc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compare</span> <span class="o">=</span> <span class="n">compare</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value_func</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="s2">&quot;Executes the call behavior.&quot;</span>
        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># 2016-04-13, 1.13.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Single-argument form of np.ma.</span><span class="si">{0}</span><span class="s2"> is deprecated. Use &quot;</span>
                <span class="s2">&quot;np.ma.</span><span class="si">{0}</span><span class="s2">.reduce instead.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
        <span class="s2">&quot;Reduce target along the given axis.&quot;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">narray</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># 2017-05-06, Numpy 1.13.0: warn on axis default</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;In the future the default for ma.</span><span class="si">{0}</span><span class="s2">.reduce will be axis=0, &quot;</span>
                <span class="s2">&quot;not the current None, to match np.</span><span class="si">{0}</span><span class="s2">.reduce. &quot;</span>
                <span class="s2">&quot;Explicitly pass 0 or None to silence this warning.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">),</span>
                <span class="n">MaskedArrayFutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fill_value_func</span><span class="p">(</span><span class="n">target</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">):</span>
                <span class="n">t</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
            <span class="k">elif</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">masked</span>
        <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="s2">&quot;Return the function applied to the outer product of a and b.&quot;</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">mb</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ma</span> <span class="ow">is</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">mb</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">nomask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ma</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">mb</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">logical_or</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">mb</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">filled</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="c1"># If obj doesn&#39;t have a min method, or if the method doesn&#39;t accept a</span>
        <span class="c1"># fill_value argument</span>
        <span class="k">return</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                   <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="nb">min</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="vm">__doc__</span>

<span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="c1"># If obj doesn&#39;t have a max method, or if the method doesn&#39;t accept a</span>
        <span class="c1"># fill_value argument</span>
        <span class="k">return</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                   <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="nb">max</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="vm">__doc__</span>


<span class="k">def</span> <span class="nf">ptp</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="k">else</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="c1"># If obj doesn&#39;t have a ptp method or if the method doesn&#39;t accept</span>
        <span class="c1"># a fill_value argument</span>
        <span class="k">return</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                   <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="n">ptp</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">ptp</span><span class="o">.</span><span class="vm">__doc__</span>


<span class="c1">##############################################################################</span>
<span class="c1">#           Definition of functions from the corresponding methods           #</span>
<span class="c1">##############################################################################</span>


<span class="k">class</span> <span class="nc">_frommethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define functions from existing MaskedArray methods.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    methodname : str</span>
<span class="sd">        Name of the method to transform.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methodname</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">methodname</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getdoc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reversed</span> <span class="o">=</span> <span class="nb">reversed</span>

    <span class="k">def</span> <span class="nf">getdoc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the doc of the function (from the doc of the method).&quot;</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>\
            <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="n">get_object_signature</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;    </span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">signature</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">doc</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reversed</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span>

        <span class="n">marr</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">marr</span><span class="p">),</span> <span class="n">method_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># use the corresponding np function</span>
            <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="n">marr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>


<span class="nb">all</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
<span class="n">anomalies</span> <span class="o">=</span> <span class="n">anom</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;anom&#39;</span><span class="p">)</span>
<span class="nb">any</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">)</span>
<span class="n">compress</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;compress&#39;</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">cumprod</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;cumprod&#39;</span><span class="p">)</span>
<span class="n">cumsum</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;cumsum&#39;</span><span class="p">)</span>
<span class="n">copy</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">)</span>
<span class="n">diagonal</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;diagonal&#39;</span><span class="p">)</span>
<span class="n">harden_mask</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;harden_mask&#39;</span><span class="p">)</span>
<span class="n">ids</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;ids&#39;</span><span class="p">)</span>
<span class="n">maximum</span> <span class="o">=</span> <span class="n">_extrema_operation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">maximum</span><span class="p">,</span> <span class="n">greater</span><span class="p">,</span> <span class="n">maximum_fill_value</span><span class="p">)</span>
<span class="n">mean</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
<span class="n">minimum</span> <span class="o">=</span> <span class="n">_extrema_operation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">minimum</span><span class="p">,</span> <span class="n">less</span><span class="p">,</span> <span class="n">minimum_fill_value</span><span class="p">)</span>
<span class="n">nonzero</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;nonzero&#39;</span><span class="p">)</span>
<span class="n">prod</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;prod&#39;</span><span class="p">)</span>
<span class="n">product</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;prod&#39;</span><span class="p">)</span>
<span class="n">ravel</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;ravel&#39;</span><span class="p">)</span>
<span class="n">repeat</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;repeat&#39;</span><span class="p">)</span>
<span class="n">shrink_mask</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;shrink_mask&#39;</span><span class="p">)</span>
<span class="n">soften_mask</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;soften_mask&#39;</span><span class="p">)</span>
<span class="n">std</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;std&#39;</span><span class="p">)</span>
<span class="nb">sum</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
<span class="n">swapaxes</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;swapaxes&#39;</span><span class="p">)</span>
<span class="c1">#take = _frommethod(&#39;take&#39;)</span>
<span class="n">trace</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;trace&#39;</span><span class="p">)</span>
<span class="n">var</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;var&#39;</span><span class="p">)</span>

<span class="n">count</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">third</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns element-wise base array raised to power from second array.</span>

<span class="sd">    This is the masked array version of `numpy.power`. For details see</span>
<span class="sd">    `numpy.power`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.power</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The *out* argument to `numpy.power` is not supported, `third` has to be</span>
<span class="sd">    None.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">third</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="s2">&quot;3-argument power not supported.&quot;</span><span class="p">)</span>
    <span class="c1"># Get the masks</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">mb</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">mb</span><span class="p">)</span>
    <span class="c1"># Get the rawdata</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="c1"># Get the type of the result (so that we preserve subclasses)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">basetype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">basetype</span> <span class="o">=</span> <span class="n">MaskedArray</span>
    <span class="c1"># Get the result and view it as a (subclass of) MaskedArray</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">umath</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">basetype</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># Find where we&#39;re in trouble w/ NaNs and Infs</span>
    <span class="n">invalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)))</span>
    <span class="c1"># Add the initial mask</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">masked</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">invalid</span><span class="p">)</span>
    <span class="c1"># Fix the invalid parts</span>
    <span class="k">if</span> <span class="n">invalid</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">masked</span>
        <span class="k">elif</span> <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">invalid</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fill_value</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="n">argmin</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;argmin&#39;</span><span class="p">)</span>
<span class="n">argmax</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;argmax&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endwith</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="s2">&quot;Function version of the eponymous method.&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># 2017-04-11, Numpy 1.13.0, gh-8701: warn on axis default</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">_deprecate_argsort_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                         <span class="n">endwith</span><span class="o">=</span><span class="n">endwith</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
<span class="n">argsort</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">argsort</span><span class="o">.</span><span class="vm">__doc__</span>

<span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endwith</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="s2">&quot;Function version of the eponymous method.&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
               <span class="n">endwith</span><span class="o">=</span><span class="n">endwith</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>
<span class="n">sort</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">sort</span><span class="o">.</span><span class="vm">__doc__</span>


<span class="k">def</span> <span class="nf">compressed</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return all the non-masked data as a 1-D array.</span>

<span class="sd">    This function is equivalent to calling the &quot;compressed&quot; method of a</span>
<span class="sd">    `MaskedArray`, see `MaskedArray.compressed` for details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MaskedArray.compressed</span>
<span class="sd">        Equivalent method.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenate a sequence of arrays along the given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays : sequence of array_like</span>
<span class="sd">        The arrays must have the same shape, except in the dimension</span>
<span class="sd">        corresponding to `axis` (the first, by default).</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which the arrays will be joined. Default is 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : MaskedArray</span>
<span class="sd">        The concatenated array with any masked entries preserved.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.concatenate : Equivalent function in the top-level NumPy module.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = ma.arange(3)</span>
<span class="sd">    &gt;&gt;&gt; a[1] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt; b = ma.arange(2, 5)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data = [0 -- 2],</span>
<span class="sd">                 mask = [False  True False],</span>
<span class="sd">           fill_value = 999999)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    masked_array(data = [2 3 4],</span>
<span class="sd">                 mask = False,</span>
<span class="sd">           fill_value = 999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.concatenate([a, b])</span>
<span class="sd">    masked_array(data = [0 -- 2 2 3 4],</span>
<span class="sd">                 mask = [False  True False False False False],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">],</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">rcls</span> <span class="o">=</span> <span class="n">get_masked_subclass</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">rcls</span><span class="p">)</span>
    <span class="c1"># Check whether one of the arrays has a non-empty mask.</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="c1"># OK, so we have to concatenate the masks</span>
    <span class="n">dm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">],</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">dm</span> <span class="o">=</span> <span class="n">dm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># If we decide to keep a &#39;_shrinkmask&#39; option, we want to check that</span>
    <span class="c1"># all of them are True, and then check for dm.any()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_shrink_mask</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract a diagonal or construct a diagonal array.</span>

<span class="sd">    This function is the equivalent of `numpy.diag` that takes masked</span>
<span class="sd">    values into account, see `numpy.diag` for details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.diag : Equivalent function for ndarrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">getmask</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>


<span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expand the shape of an array.</span>

<span class="sd">    Expands the shape of the array by including a new axis before the one</span>
<span class="sd">    specified by the `axis` parameter. This function behaves the same as</span>
<span class="sd">    `numpy.expand_dims` but preserves masked elements.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.expand_dims : Equivalent function in top-level NumPy module.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; x = ma.array([1, 2, 4])</span>
<span class="sd">    &gt;&gt;&gt; x[1] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    masked_array(data = [1 -- 4],</span>
<span class="sd">                 mask = [False  True False],</span>
<span class="sd">           fill_value = 999999)</span>
<span class="sd">    &gt;&gt;&gt; np.expand_dims(x, axis=0)</span>
<span class="sd">    array([[1, 2, 4]])</span>
<span class="sd">    &gt;&gt;&gt; ma.expand_dims(x, axis=0)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 -- 4]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False  True False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    The same result can be achieved using slicing syntax with `np.newaxis`.</span>

<span class="sd">    &gt;&gt;&gt; x[np.newaxis, :]</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 -- 4]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False  True False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">n_expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">new_shape</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">new_shape</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">left_shift</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shift the bits of an integer to the left.</span>

<span class="sd">    This is the masked array version of `numpy.left_shift`, for details</span>
<span class="sd">    see that function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.left_shift</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">right_shift</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shift the bits of an integer to the right.</span>

<span class="sd">    This is the masked array version of `numpy.right_shift`, for details</span>
<span class="sd">    see that function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.right_shift</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">right_shift</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">right_shift</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set storage-indexed locations to corresponding values.</span>

<span class="sd">    This function is equivalent to `MaskedArray.put`, see that method</span>
<span class="sd">    for details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MaskedArray.put</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We can&#39;t use &#39;frommethod&#39;, the order of arguments is different</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">narray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">putmask</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>  <span class="c1"># , mode=&#39;raise&#39;):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Changes elements of an array based on conditional and input values.</span>

<span class="sd">    This is the masked array version of `numpy.putmask`, for details see</span>
<span class="sd">    `numpy.putmask`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.putmask</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Using a masked array as `values` will **not** transform a `ndarray` into</span>
<span class="sd">    a `MaskedArray`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We can&#39;t use &#39;frommethod&#39;, the order of arguments is different</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
    <span class="p">(</span><span class="n">valdata</span><span class="p">,</span> <span class="n">valmask</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">getmask</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">a</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">valmask</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">a</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">valmask</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">mask</span> <span class="o">|=</span> <span class="n">m</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valmask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">valmask</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">valmask</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">valdata</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">return</span>


<span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Permute the dimensions of an array.</span>

<span class="sd">    This function is exactly equivalent to `numpy.transpose`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.transpose : Equivalent function in top-level NumPy module.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; x = ma.arange(4).reshape((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x[1, 1] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt;&gt; x</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 1]</span>
<span class="sd">     [2 --]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False False]</span>
<span class="sd">     [False  True]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &gt;&gt;&gt; ma.transpose(x)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 2]</span>
<span class="sd">     [1 --]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False False]</span>
<span class="sd">     [False  True]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We can&#39;t use &#39;frommethod&#39;, as &#39;transpose&#39; doesn&#39;t take keywords</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">narray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an array containing the same data with a new shape.</span>

<span class="sd">    Refer to `MaskedArray.reshape` for full documentation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MaskedArray.reshape : equivalent function</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We can&#39;t use &#39;frommethod&#39;, it whine about some parameters. Dmmit.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">_tmp</span> <span class="o">=</span> <span class="n">narray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_tmp</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new masked array with the specified size and shape.</span>

<span class="sd">    This is the masked equivalent of the `numpy.resize` function. The new</span>
<span class="sd">    array is filled with repeated copies of `x` (in the order that the</span>
<span class="sd">    data are stored in memory). If `x` is masked, the new array will be</span>
<span class="sd">    masked, and the new mask will be a repetition of the old one.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.resize : Equivalent function in the top level NumPy module.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = ma.array([[1, 2] ,[3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; a[0, 1] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 --]</span>
<span class="sd">     [3 4]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False  True]</span>
<span class="sd">     [False False]],</span>
<span class="sd">           fill_value = 999999)</span>
<span class="sd">    &gt;&gt;&gt; np.resize(a, (3, 3))</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 1, 2],</span>
<span class="sd">           [3, 4, 1]])</span>
<span class="sd">    &gt;&gt;&gt; ma.resize(a, (3, 3))</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 -- 3]</span>
<span class="sd">     [4 1 --]</span>
<span class="sd">     [3 4 1]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False  True False]</span>
<span class="sd">     [False False  True]</span>
<span class="sd">     [False False False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    A MaskedArray is always returned, regardless of the input type.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2] ,[3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; ma.resize(a, (3, 3))</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 2 3]</span>
<span class="sd">     [4 1 2]</span>
<span class="sd">     [3 4 1]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     False,</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We can&#39;t use _frommethods here, as N.resize is notoriously whiny.</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    maskedarray version of the numpy function.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Deprecated since 1.10.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 2015-04-12, 1.10.0</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;`rank` is deprecated; use the `ndim` function instead. &quot;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">VisibleDeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

<span class="n">rank</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rank</span><span class="o">.</span><span class="vm">__doc__</span>


<span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    maskedarray version of the numpy function.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

<span class="n">ndim</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="o">.</span><span class="vm">__doc__</span>


<span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="s2">&quot;maskedarray version of the numpy function.&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
<span class="n">shape</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="vm">__doc__</span>


<span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="s2">&quot;maskedarray version of the numpy function.&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
<span class="n">size</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="vm">__doc__</span>


<span class="c1">##############################################################################</span>
<span class="c1">#                            Extra functions                                 #</span>
<span class="c1">##############################################################################</span>


<span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">_NoValue</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a masked array with elements from x or y, depending on condition.</span>

<span class="sd">    Returns a masked array, shaped like condition, where the elements</span>
<span class="sd">    are from `x` when `condition` is True, and from `y` otherwise.</span>
<span class="sd">    If neither `x` nor `y` are given, the function returns a tuple of</span>
<span class="sd">    indices where `condition` is True (the result of</span>
<span class="sd">    ``condition.nonzero()``).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition : array_like, bool</span>
<span class="sd">        The condition to meet. For each True element, yield the corresponding</span>
<span class="sd">        element from `x`, otherwise from `y`.</span>
<span class="sd">    x, y : array_like, optional</span>
<span class="sd">        Values from which to choose. `x`, `y` and `condition` need to be</span>
<span class="sd">        broadcastable to some shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : MaskedArray or tuple of ndarrays</span>
<span class="sd">        The resulting masked array if `x` and `y` were given, otherwise</span>
<span class="sd">        the result of ``condition.nonzero()``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.where : Equivalent function in the top-level NumPy module.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],</span>
<span class="sd">    ...                                                    [1, 0, 1],</span>
<span class="sd">    ...                                                    [0, 1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    [[0.0 -- 2.0]</span>
<span class="sd">     [-- 4.0 --]</span>
<span class="sd">     [6.0 -- 8.0]]</span>
<span class="sd">    &gt;&gt;&gt; np.ma.where(x &gt; 5)    # return the indices where x &gt; 5</span>
<span class="sd">    (array([2, 2]), array([0, 2]))</span>

<span class="sd">    &gt;&gt;&gt; print(np.ma.where(x &gt; 5, x, -3.1416))</span>
<span class="sd">    [[-3.1416 -- -3.1416]</span>
<span class="sd">     [-- -3.1416 --]</span>
<span class="sd">     [6.0 -- 8.0]]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># handle the single-argument case</span>
    <span class="n">missing</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="n">_NoValue</span><span class="p">,</span> <span class="n">y</span> <span class="ow">is</span> <span class="n">_NoValue</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">missing</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide both &#39;x&#39; and &#39;y&#39; or neither.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">missing</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>

    <span class="c1"># we only care if the condition is true - false or masked pick y</span>
    <span class="n">cf</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">xd</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">yd</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># we need the full arrays here for correct final dimensions</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>
    <span class="n">xm</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">ym</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># deal with the fact that masked.dtype == float64, but we don&#39;t actually</span>
    <span class="c1"># want to treat it as that.</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">masked</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">masked</span><span class="p">:</span>
        <span class="n">xd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">yd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">xm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((),</span>  <span class="n">dtype</span><span class="o">=</span><span class="n">ym</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">y</span> <span class="ow">is</span> <span class="n">masked</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">masked</span><span class="p">:</span>
        <span class="n">yd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">xd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">ym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((),</span>  <span class="n">dtype</span><span class="o">=</span><span class="n">xm</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">xd</span><span class="p">,</span> <span class="n">yd</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">xm</span><span class="p">,</span> <span class="n">ym</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">mask</span><span class="p">)</span>

    <span class="c1"># collapse the mask, for backwards compatibility</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">_shrink_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use an index array to construct a new array from a set of choices.</span>

<span class="sd">    Given an array of integers and a set of n choice arrays, this method</span>
<span class="sd">    will create a new array that merges each of the choice arrays.  Where a</span>
<span class="sd">    value in `a` is i, the new array will have the value that choices[i]</span>
<span class="sd">    contains in the same place.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray of ints</span>
<span class="sd">        This array must contain integers in ``[0, n-1]``, where n is the</span>
<span class="sd">        number of choices.</span>
<span class="sd">    choices : sequence of arrays</span>
<span class="sd">        Choice arrays. The index array and all of the choices should be</span>
<span class="sd">        broadcastable to the same shape.</span>
<span class="sd">    out : array, optional</span>
<span class="sd">        If provided, the result will be inserted into this array. It should</span>
<span class="sd">        be of the appropriate shape and `dtype`.</span>
<span class="sd">    mode : {&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;}, optional</span>
<span class="sd">        Specifies how out-of-bounds indices will behave.</span>

<span class="sd">        * &#39;raise&#39; : raise an error</span>
<span class="sd">        * &#39;wrap&#39; : wrap around</span>
<span class="sd">        * &#39;clip&#39; : clip to the range</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    merged_array : array</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    choose : equivalent function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; choice = np.array([[1,1,1], [2,2,2], [3,3,3]])</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([2, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.choose(a, choice)</span>
<span class="sd">    masked_array(data = [3 2 1],</span>
<span class="sd">          mask = False,</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">fmask</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Returns the filled array, or True if masked.&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">filled</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nmask</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Returns the mask, True if ``masked``, False if ``nomask``.&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Get the indices.</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Get the masks.</span>
    <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">nmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">fmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">]</span>
    <span class="c1"># Construct the mask</span>
    <span class="n">outputmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="n">outputmask</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">mask_or</span><span class="p">(</span><span class="n">outputmask</span><span class="p">,</span> <span class="n">getmask</span><span class="p">(</span><span class="n">indices</span><span class="p">)),</span>
                           <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Get the choices.</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">outputmask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="n">d</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">outputmask</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span> <span class="nf">round_</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a copy of a, rounded to &#39;decimals&#39; places.</span>

<span class="sd">    When &#39;decimals&#39; is negative, it specifies the number of positions</span>
<span class="sd">    to the left of the decimal point.  The real and imaginary parts of</span>
<span class="sd">    complex numbers are rounded separately. Nothing is done if the</span>
<span class="sd">    array is not of float type and &#39;decimals&#39; is greater than or equal</span>
<span class="sd">    to 0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    decimals : int</span>
<span class="sd">        Number of decimals to round to. May be negative.</span>
<span class="sd">    out : array_like</span>
<span class="sd">        Existing array to use for output.</span>
<span class="sd">        If not given, returns a default copy of a.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If out is given and does not have a mask attribute, the mask of a</span>
<span class="sd">    is lost!</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
<span class="nb">round</span> <span class="o">=</span> <span class="n">round_</span>


<span class="c1"># Needed by dot, so move here from extras.py. It will still be exported</span>
<span class="c1"># from extras.py for compatibility.</span>
<span class="k">def</span> <span class="nf">mask_rowcols</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask rows and/or columns of a 2D array that contain masked values.</span>

<span class="sd">    Mask whole rows and/or columns of a 2D array that contain</span>
<span class="sd">    masked values.  The masking behavior is selected using the</span>
<span class="sd">    `axis` parameter.</span>

<span class="sd">      - If `axis` is None, rows *and* columns are masked.</span>
<span class="sd">      - If `axis` is 0, only rows are masked.</span>
<span class="sd">      - If `axis` is 1 or -1, only columns are masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like, MaskedArray</span>
<span class="sd">        The array to mask.  If not a MaskedArray instance (or if no array</span>
<span class="sd">        elements are masked).  The result is a MaskedArray with `mask` set</span>
<span class="sd">        to `nomask` (False). Must be a 2D array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to perform the operation. If None, applies to a</span>
<span class="sd">        flattened version of the array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : MaskedArray</span>
<span class="sd">        A modified version of the input array, masked depending on the value</span>
<span class="sd">        of the `axis` parameter.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If input array `a` is not 2D.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mask_rows : Mask rows of a 2D array that contain masked values.</span>
<span class="sd">    mask_cols : Mask cols of a 2D array that contain masked values.</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The input array&#39;s mask is modified by this function.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((3, 3), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[1, 1] = 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0],</span>
<span class="sd">           [0, 1, 0],</span>
<span class="sd">           [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_equal(a, 1)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 0 0]</span>
<span class="sd">     [0 -- 0]</span>
<span class="sd">     [0 0 0]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False False False]</span>
<span class="sd">     [False  True False]</span>
<span class="sd">     [False False False]],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.mask_rowcols(a)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 -- 0]</span>
<span class="sd">     [-- -- --]</span>
<span class="sd">     [0 -- 0]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False  True False]</span>
<span class="sd">     [ True  True  True]</span>
<span class="sd">     [False  True False]],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;mask_rowcols works for 2D arrays only.&quot;</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># Nothing is masked: return a</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="n">maskedval</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">a</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">axis</span><span class="p">:</span>
        <span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">maskedval</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">masked</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">maskedval</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">masked</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="c1"># Include masked dot here to avoid import problems in getting it from</span>
<span class="c1"># extras.py. Note that it is not included in __all__, but rather exported</span>
<span class="c1"># from extras in order to avoid backward compatibility problems.</span>
<span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the dot product of two arrays.</span>

<span class="sd">    This function is the equivalent of `numpy.dot` that takes masked values</span>
<span class="sd">    into account. Note that `strict` and `out` are in different position</span>
<span class="sd">    than in the method version. In order to maintain compatibility with the</span>
<span class="sd">    corresponding method, it is recommended that the optional arguments be</span>
<span class="sd">    treated as keyword only.  At some point that may be mandatory.</span>

<span class="sd">    .. note::</span>
<span class="sd">      Works only with 2-D arrays at the moment.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : masked_array_like</span>
<span class="sd">        Inputs arrays.</span>
<span class="sd">    strict : bool, optional</span>
<span class="sd">        Whether masked data are propagated (True) or set to 0 (False) for</span>
<span class="sd">        the computation. Default is False.  Propagating the mask means that</span>
<span class="sd">        if a masked value appears in a row or column, the whole row or</span>
<span class="sd">        column is considered masked.</span>
<span class="sd">    out : masked_array, optional</span>
<span class="sd">        Output argument. This must have the exact kind that would be returned</span>
<span class="sd">        if it was not used. In particular, it must have the right type, must be</span>
<span class="sd">        C-contiguous, and its dtype must be the dtype that would be returned</span>
<span class="sd">        for `dot(a,b)`. This is a performance feature. Therefore, if these</span>
<span class="sd">        conditions are not met, an exception is raised, instead of attempting</span>
<span class="sd">        to be flexible.</span>

<span class="sd">        .. versionadded:: 1.10.2</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.dot : Equivalent function for ndarrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; b = ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.dot(a, b)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[21 26]</span>
<span class="sd">     [45 64]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False False]</span>
<span class="sd">     [False False]],</span>
<span class="sd">           fill_value = 999999)</span>
<span class="sd">    &gt;&gt;&gt; np.ma.dot(a, b, strict=True)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[-- --]</span>
<span class="sd">     [-- 64]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[ True  True]</span>
<span class="sd">     [ True False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># !!!: Works only with 2D arrays. There should be a way to get it to run</span>
    <span class="c1"># with higher dimension</span>
    <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">mask_rowcols</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">mask_rowcols</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">am</span> <span class="o">=</span> <span class="o">~</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">bm</span> <span class="o">=</span> <span class="o">~</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">filled</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">m</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">am</span><span class="p">,</span> <span class="n">bm</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="n">r</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">filled</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">out</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">MaskType</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">am</span><span class="p">,</span> <span class="n">bm</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the inner product of a and b for arrays of floating point types.</span>

<span class="sd">    Like the generic NumPy equivalent the product sum is over the last dimension</span>
<span class="sd">    of a and b. The first argument is not conjugated.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fa</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fa</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">fb</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fb</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
<span class="n">inner</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doc_note</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
                         <span class="s2">&quot;Masked values are replaced by 0.&quot;</span><span class="p">)</span>
<span class="n">innerproduct</span> <span class="o">=</span> <span class="n">inner</span>


<span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="s2">&quot;maskedarray version of the numpy function.&quot;</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">)</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">mb</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ma</span> <span class="ow">is</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">mb</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">mb</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ma</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">mb</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="n">outer</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doc_note</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span>
                         <span class="s2">&quot;Masked values are replaced by 0.&quot;</span><span class="p">)</span>
<span class="n">outerproduct</span> <span class="o">=</span> <span class="n">outer</span>


<span class="k">def</span> <span class="nf">_convolve_or_correlate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">propagate_mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for ma.correlate and ma.convolve</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">propagate_mask</span><span class="p">:</span>
        <span class="c1"># results which are contributed to by either item in any pair being invalid</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">f</span><span class="p">(</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
          <span class="o">|</span> <span class="n">f</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">getdata</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># results which are not contributed to by any pair of valid elements</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">f</span><span class="p">(</span><span class="o">~</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="o">~</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">filled</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">,</span> <span class="n">propagate_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cross-correlation of two 1-dimensional sequences.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, v : array_like</span>
<span class="sd">        Input sequences.</span>
<span class="sd">    mode : {&#39;valid&#39;, &#39;same&#39;, &#39;full&#39;}, optional</span>
<span class="sd">        Refer to the `np.convolve` docstring.  Note that the default</span>
<span class="sd">        is &#39;valid&#39;, unlike `convolve`, which uses &#39;full&#39;.</span>
<span class="sd">    propagate_mask : bool</span>
<span class="sd">        If True, then a result element is masked if any masked element contributes towards it.</span>
<span class="sd">        If False, then a result element is only masked if no non-masked element</span>
<span class="sd">        contribute towards it</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : MaskedArray</span>
<span class="sd">        Discrete cross-correlation of `a` and `v`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.correlate : Equivalent function in the top-level NumPy module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_convolve_or_correlate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">propagate_mask</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">propagate_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the discrete, linear convolution of two one-dimensional sequences.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, v : array_like</span>
<span class="sd">        Input sequences.</span>
<span class="sd">    mode : {&#39;valid&#39;, &#39;same&#39;, &#39;full&#39;}, optional</span>
<span class="sd">        Refer to the `np.convolve` docstring.</span>
<span class="sd">    propagate_mask : bool</span>
<span class="sd">        If True, then if any masked element is included in the sum for a result</span>
<span class="sd">        element, then the result is masked.</span>
<span class="sd">        If False, then the result element is only masked if no non-masked cells</span>
<span class="sd">        contribute towards it</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : MaskedArray</span>
<span class="sd">        Discrete, linear convolution of `a` and `v`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.convolve : Equivalent function in the top-level NumPy module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_convolve_or_correlate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">propagate_mask</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">allequal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if all entries of a and b are equal, using</span>
<span class="sd">    fill_value as a truth value where either or both are masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array_like</span>
<span class="sd">        Input arrays to compare.</span>
<span class="sd">    fill_value : bool, optional</span>
<span class="sd">        Whether masked values in a or b are considered equal (True) or not</span>
<span class="sd">        (False).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : bool</span>
<span class="sd">        Returns True if the two arrays are equal within the given</span>
<span class="sd">        tolerance, False otherwise. If either array contains NaN,</span>
<span class="sd">        then False is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    all, any</span>
<span class="sd">    numpy.ma.allclose</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data = [10000000000.0 1e-07 --],</span>
<span class="sd">          mask = [False False  True],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    &gt;&gt;&gt; b = array([1e10, 1e-7, -42.0])</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])</span>
<span class="sd">    &gt;&gt;&gt; ma.allequal(a, b, fill_value=False)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ma.allequal(a, b)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">fill_value</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dm</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">masked_equal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if two arrays are element-wise equal within a tolerance.</span>

<span class="sd">    This function is equivalent to `allclose` except that masked values</span>
<span class="sd">    are treated as equal (default) or unequal, depending on the `masked_equal`</span>
<span class="sd">    argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array_like</span>
<span class="sd">        Input arrays to compare.</span>
<span class="sd">    masked_equal : bool, optional</span>
<span class="sd">        Whether masked values in `a` and `b` are considered equal (True) or not</span>
<span class="sd">        (False). They are considered equal by default.</span>
<span class="sd">    rtol : float, optional</span>
<span class="sd">        Relative tolerance. The relative difference is equal to ``rtol * b``.</span>
<span class="sd">        Default is 1e-5.</span>
<span class="sd">    atol : float, optional</span>
<span class="sd">        Absolute tolerance. The absolute difference is equal to `atol`.</span>
<span class="sd">        Default is 1e-8.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : bool</span>
<span class="sd">        Returns True if the two arrays are equal within the given</span>
<span class="sd">        tolerance, False otherwise. If either array contains NaN, then</span>
<span class="sd">        False is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    all, any</span>
<span class="sd">    numpy.allclose : the non-masked `allclose`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the following equation is element-wise True, then `allclose` returns</span>
<span class="sd">    True::</span>

<span class="sd">      absolute(`a` - `b`) &lt;= (`atol` + `rtol` * absolute(`b`))</span>

<span class="sd">    Return True if all elements of `a` and `b` are equal subject to</span>
<span class="sd">    given tolerances.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data = [10000000000.0 1e-07 --],</span>
<span class="sd">                 mask = [False False  True],</span>
<span class="sd">           fill_value = 1e+20)</span>
<span class="sd">    &gt;&gt;&gt; b = ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; ma.allclose(a, b)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; a = ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; b = ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; ma.allclose(a, b)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ma.allclose(a, b, masked_equal=False)</span>
<span class="sd">    False</span>

<span class="sd">    Masked values are not compared directly.</span>

<span class="sd">    &gt;&gt;&gt; a = ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; b = ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; ma.allclose(a, b)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ma.allclose(a, b, masked_equal=False)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># make sure y is an inexact type to avoid abs(MIN_INT); will cause</span>
    <span class="c1"># casting of x later.</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">getmask</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="n">xinf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">masked_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">))</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># If we have some infs, they should fall at the same place.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">xinf</span> <span class="o">==</span> <span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="kc">False</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># No infs at all</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">xinf</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">less_equal</span><span class="p">(</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">),</span> <span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">absolute</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span>
                   <span class="n">masked_equal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">xinf</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">xinf</span><span class="p">],</span> <span class="n">masked_equal</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">xinf</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="n">xinf</span><span class="p">]</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">less_equal</span><span class="p">(</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">),</span> <span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">absolute</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span>
               <span class="n">masked_equal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the input to a masked array of the given data-type.</span>

<span class="sd">    No copy is performed if the input is already an `ndarray`. If `a` is</span>
<span class="sd">    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data, in any form that can be converted to a masked array. This</span>
<span class="sd">        includes lists, lists of tuples, tuples, tuples of tuples, tuples</span>
<span class="sd">        of lists, ndarrays and masked arrays.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        By default, the data-type is inferred from the input data.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Whether to use row-major (&#39;C&#39;) or column-major (&#39;FORTRAN&#39;) memory</span>
<span class="sd">        representation.  Default is &#39;C&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : MaskedArray</span>
<span class="sd">        Masked array interpretation of `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    asanyarray : Similar to `asarray`, but conserves subclasses.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(10.).reshape(2, 5)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[ 0.,  1.,  2.,  3.,  4.],</span>
<span class="sd">           [ 5.,  6.,  7.,  8.,  9.]])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.asarray(x)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[ 0.  1.  2.  3.  4.]</span>
<span class="sd">     [ 5.  6.  7.  8.  9.]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     False,</span>
<span class="sd">           fill_value = 1e+20)</span>
<span class="sd">    &gt;&gt;&gt; type(np.ma.asarray(x))</span>
<span class="sd">    &lt;class &#39;numpy.ma.core.MaskedArray&#39;&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">order</span> <span class="ow">or</span> <span class="s1">&#39;C&#39;</span>
    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the input to a masked array, conserving subclasses.</span>

<span class="sd">    If `a` is a subclass of `MaskedArray`, its class is conserved.</span>
<span class="sd">    No copy is performed if the input is already an `ndarray`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data, in any form that can be converted to an array.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        By default, the data-type is inferred from the input data.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Whether to use row-major (&#39;C&#39;) or column-major (&#39;FORTRAN&#39;) memory</span>
<span class="sd">        representation.  Default is &#39;C&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : MaskedArray</span>
<span class="sd">        MaskedArray interpretation of `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    asarray : Similar to `asanyarray`, but does not conserve subclass.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(10.).reshape(2, 5)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[ 0.,  1.,  2.,  3.,  4.],</span>
<span class="sd">           [ 5.,  6.,  7.,  8.,  9.]])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.asanyarray(x)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[ 0.  1.  2.  3.  4.]</span>
<span class="sd">     [ 5.  6.  7.  8.  9.]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     False,</span>
<span class="sd">           fill_value = 1e+20)</span>
<span class="sd">    &gt;&gt;&gt; type(np.ma.asanyarray(x))</span>
<span class="sd">    &lt;class &#39;numpy.ma.core.MaskedArray&#39;&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># workaround for #8666, to preserve identity. Ideally the bottom line</span>
    <span class="c1"># would handle this for us.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="c1">##############################################################################</span>
<span class="c1">#                               Pickling                                     #</span>
<span class="c1">##############################################################################</span>

<span class="k">def</span> <span class="nf">_pickle_warn</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="c1"># NumPy 1.15.0, 2017-12-10</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;np.ma.</span><span class="si">{method}</span><span class="s2"> is deprecated, use pickle.</span><span class="si">{method}</span><span class="s2"> instead&quot;</span>
            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">),</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pickle a masked array to a file.</span>

<span class="sd">    This is a wrapper around ``cPickle.dump``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : MaskedArray</span>
<span class="sd">        The array to be pickled.</span>
<span class="sd">    F : str or file-like object</span>
<span class="sd">        The file to pickle `a` to. If a string, the full path to the file.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pickle_warn</span><span class="p">(</span><span class="s1">&#39;dump&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;readline&#39;</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">F</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">dumps</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string corresponding to the pickling of a masked array.</span>

<span class="sd">    This is a wrapper around ``cPickle.dumps``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : MaskedArray</span>
<span class="sd">        The array for which the string representation of the pickle is</span>
<span class="sd">        returned.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pickle_warn</span><span class="p">(</span><span class="s1">&#39;dumps&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper around ``cPickle.load`` which accepts either a file-like object</span>
<span class="sd">    or a filename.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    F : str or file</span>
<span class="sd">        The file or file name to load.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dump : Pickle an array</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is different from `numpy.load`, which does not use cPickle but loads</span>
<span class="sd">    the NumPy binary .npy format.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pickle_warn</span><span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;readline&#39;</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">F</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">loads</span><span class="p">(</span><span class="n">strg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a pickle from the current string.</span>

<span class="sd">    The result of ``cPickle.loads(strg)`` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    strg : str</span>
<span class="sd">        The string to load.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dumps : Return a string corresponding to the pickling of a masked array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pickle_warn</span><span class="p">(</span><span class="s1">&#39;loads&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">strg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">count</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;fromfile() not yet implemented for a MaskedArray.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fromflex</span><span class="p">(</span><span class="n">fxarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a masked array from a suitable flexible-type array.</span>

<span class="sd">    The input array has to have a data-type with ``_data`` and ``_mask``</span>
<span class="sd">    fields. This type of array is output by `MaskedArray.toflex`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fxarray : ndarray</span>
<span class="sd">        The structured input array, containing ``_data`` and ``_mask``</span>
<span class="sd">        fields. If present, other fields are discarded.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : MaskedArray</span>
<span class="sd">        The constructed masked array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MaskedArray.toflex : Build a flexible-type array from a masked array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[0] + [1, 0] * 4)</span>
<span class="sd">    &gt;&gt;&gt; rec = x.toflex()</span>
<span class="sd">    &gt;&gt;&gt; rec</span>
<span class="sd">    array([[(0, False), (1, True), (2, False)],</span>
<span class="sd">           [(3, True), (4, False), (5, True)],</span>
<span class="sd">           [(6, False), (7, True), (8, False)]],</span>
<span class="sd">          dtype=[(&#39;_data&#39;, &#39;&lt;i4&#39;), (&#39;_mask&#39;, &#39;|b1&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; x2 = np.ma.fromflex(rec)</span>
<span class="sd">    &gt;&gt;&gt; x2</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 -- 2]</span>
<span class="sd">     [-- 4 --]</span>
<span class="sd">     [6 -- 8]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False  True False]</span>
<span class="sd">     [ True False  True]</span>
<span class="sd">     [False  True False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    Extra fields can be present in the structured array but are discarded:</span>

<span class="sd">    &gt;&gt;&gt; dt = [(&#39;_data&#39;, &#39;&lt;i4&#39;), (&#39;_mask&#39;, &#39;|b1&#39;), (&#39;field3&#39;, &#39;&lt;f4&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; rec2 = np.zeros((2, 2), dtype=dt)</span>
<span class="sd">    &gt;&gt;&gt; rec2</span>
<span class="sd">    array([[(0, False, 0.0), (0, False, 0.0)],</span>
<span class="sd">           [(0, False, 0.0), (0, False, 0.0)]],</span>
<span class="sd">          dtype=[(&#39;_data&#39;, &#39;&lt;i4&#39;), (&#39;_mask&#39;, &#39;|b1&#39;), (&#39;field3&#39;, &#39;&lt;f4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = np.ma.fromflex(rec2)</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 0]</span>
<span class="sd">     [0 0]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False False]</span>
<span class="sd">     [False False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">fxarray</span><span class="p">[</span><span class="s1">&#39;_data&#39;</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">fxarray</span><span class="p">[</span><span class="s1">&#39;_mask&#39;</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">_convert2ma</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert functions from numpy to numpy.ma.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        _methodname : string</span>
<span class="sd">            Name of the method to transform.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">funcname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getdoc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extras</span> <span class="o">=</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">getdoc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the doc of the function (from the doc of the method).&quot;</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">get_object_signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">doc</span><span class="p">:</span>
            <span class="c1"># Add the signature of the function at the beginning of the doc</span>
            <span class="k">if</span> <span class="n">sig</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">+</span> <span class="n">doc</span>
        <span class="k">return</span> <span class="n">doc</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="c1"># Find the common parameters to the call and the definition</span>
        <span class="n">_extras</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extras</span>
        <span class="n">common_params</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">_extras</span><span class="p">)</span>
        <span class="c1"># Drop the common parameters from the call</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">common_params</span><span class="p">:</span>
            <span class="n">_extras</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="c1"># Get the result</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;fill_value&quot;</span> <span class="ow">in</span> <span class="n">common_params</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">_extras</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fill_value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;hardmask&quot;</span> <span class="ow">in</span> <span class="n">common_params</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_hardmask</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">_extras</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;hard_mask&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="n">arange</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;arange&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">clip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span>
<span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span>
<span class="n">empty</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">empty_like</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;empty_like&#39;</span><span class="p">)</span>
<span class="n">frombuffer</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;frombuffer&#39;</span><span class="p">)</span>
<span class="n">fromfunction</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;fromfunction&#39;</span><span class="p">)</span>
<span class="n">identity</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span>
    <span class="s1">&#39;identity&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span>
<span class="n">ones</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;ones&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">ones_like</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span>
<span class="n">squeeze</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span>
<span class="n">zeros</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;zeros&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">zeros_like</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span>


<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Append values to the end of an array.</span>

<span class="sd">    .. versionadded:: 1.9.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Values are appended to a copy of this array.</span>
<span class="sd">    b : array_like</span>
<span class="sd">        These values are appended to a copy of `a`.  It must be of the</span>
<span class="sd">        correct shape (the same shape as `a`, excluding `axis`).  If `axis`</span>
<span class="sd">        is not specified, `b` can be any shape and will be flattened</span>
<span class="sd">        before use.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which `v` are appended.  If `axis` is not given,</span>
<span class="sd">        both `a` and `b` are flattened before use.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    append : MaskedArray</span>
<span class="sd">        A copy of `a` with `b` appended to `axis`.  Note that `append`</span>
<span class="sd">        does not occur in-place: a new array is allocated and filled.  If</span>
<span class="sd">        `axis` is None, the result is a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.append : Equivalent function in the top-level NumPy module.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_values([1, 2, 3], 2)</span>
<span class="sd">    &gt;&gt;&gt; b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)</span>
<span class="sd">    &gt;&gt;&gt; print(ma.append(a, b))</span>
<span class="sd">    [1 -- 3 4 5 6 -- 8 9]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">axis</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/StonerLogo2.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="related bottom">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../../../index.html">Stoner Package</a></li>
      <li>
        <a href="../../index.html">Module code</a>
      </li> 
    </ul>
  </nav>
  </div>
  <footer id="pagefooter">&copy; 2013-15, Gavin Burnell et al.Last updated on Dec 06, 2018.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a>
      1.7.9
        with the <a href="http://github.com/irskep/sphinx-better-theme">
          better</a> theme.

  </footer>

  
  </body>
</html>